// ===== .\Dependence\common\condition.cpp =====

﻿#include "condition.h"

#include <iostream>
#include <vector>
#include <sstream>
#include <memory>
#include <cmath>
#include <stack>
#include <algorithm>
#include <cctype>
#include <locale>


using namespace std;

class VariableExpression : public Expression {
private:
    string name;
public:
    VariableExpression(const string& n) : name(n) {}

    ValueType Evaluate(function<ValueType(const string&)> getValue) const override {
        return getValue(name);
    }
};

class ConstantExpression : public Expression {
private:
    ValueType value;
public:
    ConstantExpression(ValueType v) : value(v) {}

    ValueType Evaluate(function<ValueType(const string&)> getValue) const override {
        return value;
    }
};

class ArrayExpression : public Expression {
private:
    vector<shared_ptr<Expression>> elements;

public:
    ArrayExpression(vector<shared_ptr<Expression>> es)
        : elements(move(es)) {
    }

    ValueType Evaluate(function<ValueType(const string&)> getValue) const override {
        string result = "[";
        for (size_t i = 0; i < elements.size(); ++i) {
            auto value = elements[i]->Evaluate(getValue);
            result += ToString(value);
            if (i < elements.size() - 1) {
                result += ", ";
            }
        }
        result += "]";
        return result;
    }

    // 获取数组元素的值（用于in操作符）
    vector<ValueType> GetElementValues(function<ValueType(const string&)> getValue) const {
        vector<ValueType> values;
        for (const auto& element : elements) {
            values.push_back(element->Evaluate(getValue));
        }
        return values;
    }
};

class UnaryExpression : public Expression {
private:
    UnaryOperator operand;
    shared_ptr<Expression> expression;

public:
    UnaryExpression(UnaryOperator op, shared_ptr<Expression> operand)
        : operand(op), expression(move(operand)) {
    }

    ValueType Evaluate(function<ValueType(const string&)> getValue) const override {
        auto value = expression->Evaluate(getValue);

        switch (operand) {
        case UnaryOperator::NEGATE:
            return ApplyNegate(value);
        case UnaryOperator::LOGICAL_NOT:
            return ApplyLogicalNot(value);
        default:
            THROW_EXCEPTION(InvalidConfigException, "Unknown unary operator.\n");
        }
    }

private:
    ValueType ApplyNegate(const ValueType& value) const {
        return visit([](const auto& v) -> ValueType {
            using T = decay_t<decltype(v)>;
            if constexpr (is_arithmetic_v<T> && !is_same_v<T, bool>) {
                return -v;
            }
            else {
                THROW_EXCEPTION(InvalidConfigException, "Cannot apply negate to boolean or non-numeric type.\n");
            }
            }, value);
    }

    ValueType ApplyLogicalNot(const ValueType& value) const {
        bool bool_val = ConvertToBool(value);
        return !bool_val;
    }

    bool ConvertToBool(const ValueType& value) const {
        return visit([](const auto& v) -> bool {
            using T = decay_t<decltype(v)>;
            if constexpr (is_same_v<T, bool>) {
                return v;
            }
            else if constexpr (is_same_v<T, int>) {
                return v != 0;
            }
            else if constexpr (is_same_v<T, double>) {
                return abs(v) > 1e-10; // 考虑浮点误差
            }
            else if constexpr (is_same_v<T, string>) {
                return !v.empty();
            }
            else {
                return false;
            }
            }, value);
    }
};

class BinaryExpression : public Expression {
private:
    shared_ptr<Expression> left;
    shared_ptr<Expression> right;
    Operator operand;

public:
    BinaryExpression(shared_ptr<Expression> l,
        shared_ptr<Expression> r,
        Operator op)
        : left(move(l)), right(move(r)), operand(op) {
    }

    ValueType Evaluate(function<ValueType(const string&)> getValue) const override {
        if (operand == Operator::INCLUDE) {
            auto array_expr = dynamic_cast<ArrayExpression*>(right.get());
            if (!array_expr) {
                THROW_EXCEPTION(InvalidConfigException, "Right operand of 'in' must be an array.\n");
            }

            auto array_values = array_expr->GetElementValues(getValue);
            bool found = false;

            auto left_val = left->Evaluate(getValue);
            for (const auto& array_val : array_values) {
                if (GetComparisonResult(left_val, array_val, Operator::EQUAL)) {
                    found = true;
                    break;
                }
            }

            return found;
        }

        if (operand == Operator::LOGICAL_AND) {
            bool left_val = ConvertToBool(left->Evaluate(getValue));
            if (!left_val) return false;
            bool right_val = ConvertToBool(right->Evaluate(getValue));
            return right_val;
        }

        if (operand == Operator::LOGICAL_OR) {
            bool left_val = ConvertToBool(left->Evaluate(getValue));
            if (left_val) return true;
            bool right_val = ConvertToBool(right->Evaluate(getValue));
            return right_val;
        }

        auto left_val = left->Evaluate(getValue);
        auto right_val = right->Evaluate(getValue);

        switch (operand) {
        case Operator::EQUAL:
        case Operator::NOT_EQUAL:
        case Operator::GREATER:
        case Operator::GREATER_EQUAL:
        case Operator::LESS:
        case Operator::LESS_EQUAL:
            return CompareValues(left_val, right_val, operand);

        case Operator::ADD:
        case Operator::SUBTRACT:
        case Operator::MULTIPLY:
        case Operator::DIVIDE:
        case Operator::MODULO:
        case Operator::EXPONENT:
            return ComputeArithmetic(left_val, right_val, operand);

        default:
            THROW_EXCEPTION(InvalidConfigException, "Unknown operator.\n");
        }
    }

private:
    bool GetComparisonResult(const ValueType& left, const ValueType& right, Operator op) const {
        ValueType result = CompareValues(left, right, op);
        if (auto bool_result = get_if<bool>(&result)) {
            return *bool_result;
        }
        THROW_EXCEPTION(InvalidConfigException, "Comparison must return boolean value.\n");
    }

    ValueType CompareValues(const ValueType& left, const ValueType& right, Operator op) const {
        bool result = visit([op](const auto& l, const auto& r) -> bool {
            using T1 = decay_t<decltype(l)>;
            using T2 = decay_t<decltype(r)>;

            if constexpr (is_same_v<T1, T2>) {
                return CompareSameType(l, r, op);
            }
            else {
                return CompareDifferentType(l, r, op);
            }
            }, left, right);

        return result;
    }

    template<typename T>
    static bool CompareSameType(const T& left, const T& right, Operator op) {
        switch (op) {
        case Operator::EQUAL: return left == right;
        case Operator::NOT_EQUAL: return left != right;
        case Operator::GREATER: return left > right;
        case Operator::GREATER_EQUAL: return left >= right;
        case Operator::LESS: return left < right;
        case Operator::LESS_EQUAL: return left <= right;
        default: return false;
        }
    }

    template<typename T1, typename T2>
    static bool CompareDifferentType(const T1& left, const T2& right, Operator op) {
        if constexpr (is_arithmetic_v<T1> && is_arithmetic_v<T2>) {
            double l = static_cast<double>(left);
            double r = static_cast<double>(right);
            return CompareSameType(l, r, op);
        }
        else if constexpr (is_same_v<T1, string> || is_same_v<T2, string>) {
            string l_str = toString(left);
            string r_str = toString(right);
            return CompareSameType(l_str, r_str, op);
        }
        else {
            return false;
        }
    }

    ValueType ComputeArithmetic(const ValueType& left, const ValueType& right, Operator op) const {
        return visit([op](const auto& l, const auto& r) -> ValueType {
            using T1 = decay_t<decltype(l)>;
            using T2 = decay_t<decltype(r)>;

            // 如果两个操作数都是整数，进行整数运算
            if constexpr (is_same_v<T1, int> && is_same_v<T2, int>) {
                switch (op) {
                case Operator::ADD: return l + r;
                case Operator::SUBTRACT: return l - r;
                case Operator::MULTIPLY: return l * r;
                case Operator::DIVIDE:
                    if (r == 0) {
                        THROW_EXCEPTION(ArithmeticException, "Division by zero.\n");
                    }
                    // 整数除法，返回整数结果
                    return l / r;
                case Operator::MODULO:
                    if (r == 0) {
                        THROW_EXCEPTION(ArithmeticException, "Modulo by zero.\n");
                    }
                    return l % r;
                case Operator::EXPONENT: {
                    // 整数指数运算
                    if (r < 0) {
                        // 负指数会产生浮点数，转为double计算
                        double result = pow(static_cast<double>(l), static_cast<double>(r));
                        return result;
                    }
                    // 非负指数，进行整数运算
                    int result = 1;
                    for (int i = 0; i < r; ++i) {
                        result *= l;
                    }
                    return result;
                }
                default:
                    THROW_EXCEPTION(ArithmeticException, "Unsupported arithmetic operator.\n");
                }
            }
            // 如果至少有一个操作数是浮点数，进行浮点数运算
            else if constexpr ((is_arithmetic_v<T1> && is_arithmetic_v<T2>) &&
                !(is_same_v<T1, bool> || is_same_v<T2, bool>)) {
                double l_val = static_cast<double>(l);
                double r_val = static_cast<double>(r);

                switch (op) {
                case Operator::ADD: return l_val + r_val;
                case Operator::SUBTRACT: return l_val - r_val;
                case Operator::MULTIPLY: return l_val * r_val;
                case Operator::DIVIDE:
                    if (abs(r_val) < 1e-10) {
                        THROW_EXCEPTION(ArithmeticException, "Division by zero.\n");
                    }
                    return l_val / r_val;
                case Operator::MODULO:
                    if (abs(r_val) < 1e-10) {
                        THROW_EXCEPTION(ArithmeticException, "Modulo by zero.\n");
                    }
                    return fmod(l_val, r_val);
                case Operator::EXPONENT:
                    return pow(l_val, r_val);
                default:
                    THROW_EXCEPTION(ArithmeticException, "Unsupported arithmetic operator.\n");
                }
            }
            else {
                THROW_EXCEPTION(ArithmeticException, "Arithmetic operations only supported for numeric types.\n");
            }
            }, left, right);
    }

    bool ConvertToBool(const ValueType& value) const {
        return visit([](const auto& v) -> bool {
            using T = decay_t<decltype(v)>;
            if constexpr (is_same_v<T, bool>) {
                return v;
            }
            else if constexpr (is_same_v<T, int>) {
                return v != 0;  // 整数不为0就是true
            }
            else if constexpr (is_same_v<T, double>) {
                return abs(v) > 1e-10; // 浮点数不为0就是true
            }
            else if constexpr (is_same_v<T, string>) {
                return !v.empty();
            }
            else {
                return false;
            }
            }, value);
    }

    template<typename T>
    static string toString(const T& value) {
        if constexpr (is_same_v<T, string>) {
            return value;
        }
        else if constexpr (is_same_v<T, bool>) {
            return value ? "true" : "false";
        }
        else {
            return to_string(value);
        }
    }
};

bool Condition::ParseCondition(const string& conditionStr) {
    try {
        vector<string> tokens = Tokenize(conditionStr);
        if (tokens.size() > 0)root = ParseExpression(tokens);
        return true;
    }
    catch (const exception& e) {
        cerr << "Parse error: " << e.what() << endl;
        return false;
    }
}

bool Condition::EvaluateBool(function<ValueType(const string&)> getValue) const {
    if (!root) {
        return true;
    }

    auto result = root->Evaluate(getValue);
    if (auto bool_val = get_if<bool>(&result)) {
        return *bool_val;
    }
    THROW_EXCEPTION(InvalidConfigException, "Condition must Evaluate to boolean.\n");
}

ValueType Condition::EvaluateValue(function<ValueType(const string&)> getValue) const {
    if (!root) {
        return 0;
    }
    return root->Evaluate(getValue);
}

vector<string> Condition::Tokenize(const string& expr) {
    vector<string> tokens;
    string current;

    for (size_t i = 0; i < expr.length(); ++i) {
        char c = expr[i];

        if (IsSpaceChar(c)) {
            if (!current.empty()) {
                tokens.push_back(current);
                current.clear();
            }
        }
        else if (IsOperatorChar(c) || c == '(' || c == ')' || c == '[' || c == ']' || c == ',') {
            if (!current.empty()) {
                tokens.push_back(current);
                current.clear();
            }

            // 处理双字符运算符
            if ((c == '&' && i + 1 < expr.length() && expr[i + 1] == '&') ||
                (c == '|' && i + 1 < expr.length() && expr[i + 1] == '|') ||
                (c == '=' && i + 1 < expr.length() && expr[i + 1] == '=') ||
                (c == '!' && i + 1 < expr.length() && expr[i + 1] == '=') ||
                (c == '<' && i + 1 < expr.length() && expr[i + 1] == '=') ||
                (c == '>' && i + 1 < expr.length() && expr[i + 1] == '=')) {
                tokens.push_back(string(1, c) + string(1, expr[i + 1]));
                i++;
            }
            else {
                tokens.push_back(string(1, c));
            }
        }
        else {
            current += c;
        }
    }

    if (!current.empty()) {
        tokens.push_back(current);
    }

    return tokens;
}

bool Condition::OperatorChar(char c) {
    return IsOperatorChar(c);
}

shared_ptr<Expression> Condition::ParseExpression(const vector<string>& tokens) {
    vector<string> postfix = InfixToPostfix(tokens);
    return ParsePostfix(postfix);
}

vector<string> Condition::InfixToPostfix(const vector<string>& infix) {
    vector<string> postfix;
    stack<string> opStack;

    for (const auto& token : infix) {
        if (IsOperator(token)) {
            while (!opStack.empty() && opStack.top() != "(" &&
                HigherPrecedence(opStack.top(), token)) {
                postfix.push_back(opStack.top());
                opStack.pop();
            }
            opStack.push(token);
        }
        else if (token == "(") {
            opStack.push(token);
        }
        else if (token == ")") {
            while (!opStack.empty() && opStack.top() != "(") {
                postfix.push_back(opStack.top());
                opStack.pop();
            }
            if (opStack.empty()) {
                THROW_EXCEPTION(InvalidConfigException, "Mismatched parentheses.\n");
            }
            opStack.pop();
        }
        else if (token == "[") {
            postfix.push_back(token);
        }
        else if (token == "]") {
            postfix.push_back(token);
        }
        else {
            postfix.push_back(token);
        }
    }

    while (!opStack.empty()) {
        if (opStack.top() == "(") {
            THROW_EXCEPTION(InvalidConfigException, "Mismatched parentheses.\n");
        }
        postfix.push_back(opStack.top());
        opStack.pop();
    }

    return postfix;
}

shared_ptr<Expression> Condition::ParsePostfix(const vector<string>& postfix) {
    stack<shared_ptr<Expression>> exprStack;

    for (size_t i = 0; i < postfix.size(); ++i) {
        const auto& token = postfix[i];

        if (token == "[") {
            vector<shared_ptr<Expression>> elements;
            size_t j = i + 1;

            while (j < postfix.size() && postfix[j] != "]") {
                if (postfix[j] == ",") {
                    j++;
                    continue;
                }

                if (IsOperator(postfix[j])) {
                    THROW_EXCEPTION(InvalidConfigException, "Unexpected operator in array: " + postfix[j] + ".\n");
                }

                elements.push_back(ParseOperand(postfix[j]));
                j++;
            }

            if (j >= postfix.size() || postfix[j] != "]") {
                THROW_EXCEPTION(InvalidConfigException, "Unclosed array.\n");
            }

            exprStack.push(make_unique<ArrayExpression>(move(elements)));
            i = j;
        }
        else if (IsOperator(token)) {
            if (exprStack.size() < 2) {
                THROW_EXCEPTION(InvalidConfigException, "Insufficient operands for operator: " + token + ".\n");
            }

            auto right = move(exprStack.top());
            exprStack.pop();
            auto left = move(exprStack.top());
            exprStack.pop();

            Operator op = GetOperator(token);
            exprStack.push(make_unique<BinaryExpression>(move(left), move(right), op));
        }
        else if (token == "-" && exprStack.size() == 1) {
            auto operand = move(exprStack.top());
            exprStack.pop();
            exprStack.push(make_unique<UnaryExpression>(UnaryOperator::NEGATE, move(operand)));
        }
        else if (token == "!" && exprStack.size() >= 1) {
            auto operand = move(exprStack.top());
            exprStack.pop();
            exprStack.push(make_unique<UnaryExpression>(UnaryOperator::LOGICAL_NOT, move(operand)));
        }
        else {
            exprStack.push(ParseOperand(token));
        }
    }

    if (exprStack.size() != 1) {
        THROW_EXCEPTION(InvalidConfigException, "Invalid expression.\n");
    }

    return move(exprStack.top());
}

bool Condition::IsOperator(const string& token) {
    return token == "+" || token == "-" || token == "*" || token == "/" ||
        token == "%" || token == "^" || token == "==" || token == "!=" ||
        token == ">" || token == ">=" || token == "<" || token == "<=" ||
        token == "in" || token == "&&" || token == "||";
}

bool Condition::HigherPrecedence(const string& op1, const string& op2) {
    int prec1 = GetPrecedence(op1);
    int prec2 = GetPrecedence(op2);

    if (prec1 == prec2) {
        return !RightAssociative(op1);
    }
    return prec1 > prec2;
}

int Condition::GetPrecedence(const string& op) {
    if (op == "!" || op == "negate") return 8;
    if (op == "^") return 7;
    if (op == "*" || op == "/" || op == "%") return 6;
    if (op == "+" || op == "-") return 5;
    if (op == "in") return 4;
    if (op == "==" || op == "!=" || op == ">" || op == ">=" || op == "<" || op == "<=") return 4;
    if (op == "&&") return 3;
    if (op == "||") return 2;
    return 0;
}

bool Condition::RightAssociative(const string& op) {
    return op == "^" || op == "!";
}

Operator Condition::GetOperator(const string& token) {
    if (token == "==") return Operator::EQUAL;
    else if (token == "!=") return Operator::NOT_EQUAL;
    else if (token == ">") return Operator::GREATER;
    else if (token == ">=") return Operator::GREATER_EQUAL;
    else if (token == "<") return Operator::LESS;
    else if (token == "<=") return Operator::LESS_EQUAL;
    else if (token == "in") return Operator::INCLUDE;
    else if (token == "+") return Operator::ADD;
    else if (token == "-") return Operator::SUBTRACT;
    else if (token == "*") return Operator::MULTIPLY;
    else if (token == "/") return Operator::DIVIDE;
    else if (token == "%") return Operator::MODULO;
    else if (token == "^") return Operator::EXPONENT;
    else if (token == "&&") return Operator::LOGICAL_AND;
    else if (token == "||") return Operator::LOGICAL_OR;
    else throw runtime_error("Unknown operator: " + token);
}

shared_ptr<Expression> Condition::ParseOperand(const string& token) {
    // 变量（支持中文变量名）
    if (token.length() >= 2 && token.substr(0, 2) == "$$") {
        string varName = token.substr(2);
        // 检查变量名是否合法（支持中文字符）
        if (!varName.empty() && (isalpha(static_cast<unsigned char>(varName[0])) ||
            varName[0] == '_' ||
            (varName[0] & 0x80))) {
            return make_unique<VariableExpression>(varName);
        }
    }

    // 常量
    return ParseConstant(token);
}

shared_ptr<Expression> Condition::ParseConstant(const string& token) {
    if (token == "true") {
        return make_unique<ConstantExpression>(true);
    }
    else if (token == "false") {
        return make_unique<ConstantExpression>(false);
    }

    // 首先尝试解析为整数
    try {
        size_t pos;
        int int_val = stoi(token, &pos);
        if (pos == token.length()) {
            // 检查是否是以0开头的多位数（如"01"），这种情况应该保持为字符串
            if (token.length() > 1 && token[0] == '0' && isdigit(token[1])) {
                // 这种情况应该保持为字符串
            }
            else {
                return make_unique<ConstantExpression>(int_val);
            }
        }
    }
    catch (...) {}

    // 尝试解析为浮点数
    try {
        size_t pos;
        double double_val = stod(token, &pos);
        if (pos == token.length()) {
            // 检查是否包含小数点或科学计数法
            if (token.find('.') != string::npos ||
                token.find('e') != string::npos ||
                token.find('E') != string::npos) {
                return make_unique<ConstantExpression>(double_val);
            }
            else {
                // 没有小数点但解析为double，说明数字太大，保持为整数
                return make_unique<ConstantExpression>(static_cast<int>(double_val));
            }
        }
    }
    catch (...) {}

    // 处理字符串（支持中文字符串）
    string str_val = token;
    if (str_val.length() >= 2 &&
        ((str_val.front() == '"' && str_val.back() == '"') ||
            (str_val.front() == '\'' && str_val.back() == '\''))) {
        str_val = str_val.substr(1, str_val.length() - 2);
    }

    return make_unique<ConstantExpression>(str_val);
}

bool IsOperatorChar(char c) {
    return c == '=' || c == '!' || c == '>' || c == '<' ||
        c == '+' || c == '-' || c == '*' || c == '/' ||
        c == '%' || c == '^' || c == '&' || c == '|';
}

bool IsSpaceChar(char c) {
    return isspace(static_cast<unsigned char>(c)) ||
        c == '　'; // 中文全角空格
}

bool IsIdentifierChar(char c) {
    return isalnum(static_cast<unsigned char>(c)) ||
        c == '_' ||
        (c >= 0x80 && c <= 0xFF); // 支持中文字符和其他扩展字符
}

string ToString(const ValueType& value) {
    return visit([](const auto& v) -> string {
        using T = decay_t<decltype(v)>;

        if constexpr (is_same_v<T, int>) {
            return to_string(v);
        }
        else if constexpr (is_same_v<T, double>) {
            string str = to_string(v);
            size_t dot_pos = str.find('.');
            if (dot_pos != string::npos) {
                size_t last_non_zero = str.find_last_not_of('0');
                if (last_non_zero != string::npos && last_non_zero > dot_pos) {
                    if (str[last_non_zero] == '.') {
                        str = str.substr(0, last_non_zero);
                    }
                    else {
                        str = str.substr(0, last_non_zero + 1);
                    }
                }
            }
            return str;
        }
        else if constexpr (is_same_v<T, bool>) {
            return v ? "true" : "false";
        }
        else if constexpr (is_same_v<T, string>) {
            return v;
        }
        else {
            return "unknown_type";
        }
        }, value);
}

ValueType FromString(const string& s) {
    if (s.empty()) {
        return string("");
    }

    if (s == "true") {
        return true;
    }

    if (s == "false") {
        return false;
    }

    // 处理带引号的字符串（支持中文）
    if (s.length() >= 2 &&
        ((s.front() == '"' && s.back() == '"') ||
            (s.front() == '\'' && s.back() == '\''))) {
        return s.substr(1, s.length() - 2);
    }

    // 检查是否包含非ASCII字符，如果有则直接返回字符串
    for (char c : s) {
        if (static_cast<unsigned char>(c) > 127) {
            return s;
        }
    }

    try {
        size_t pos;
        int int_val = stoi(s, &pos);
        if (pos == s.length()) {
            return int_val;
        }
    }
    catch (const exception&) {}

    // 尝试解析为浮点数
    try {
        size_t pos;
        double double_val = stod(s, &pos);
        if (pos == s.length()) {
            return double_val;
        }
    }
    catch (const exception&) {}

    bool is_all_digit = !s.empty();
    for (char c : s) {
        if (!isdigit(static_cast<unsigned char>(c))) {
            is_all_digit = false;
            break;
        }
    }

    if (is_all_digit) {
        if ((s.length() > 1 && s[0] == '0') || s.length() > 10) {
            return s;
        }
        try {
            return stoi(s);
        }
        catch (...) {
            return s;
        }
    }

    if (!s.empty() && isdigit(static_cast<unsigned char>(s[0]))) {
        bool has_non_digit = false;
        bool has_dot = false;
        bool has_exponent = false;

        for (size_t i = 0; i < s.length(); ++i) {
            char c = s[i];
            if (!isdigit(static_cast<unsigned char>(c))) {
                if (c == '.' && !has_dot) {
                    has_dot = true;
                }
                else if ((c == 'e' || c == 'E') && !has_exponent) {
                    has_exponent = true;
                    if (i + 1 < s.length() && (s[i + 1] == '+' || s[i + 1] == '-')) {
                        i++;
                    }
                }
                else {
                    has_non_digit = true;
                    break;
                }
            }
        }

        if (!has_non_digit && (has_dot || has_exponent)) {
            try {
                return stod(s);
            }
            catch (...) {}
        }
    }

    return s;
}




// ===== .\Dependence\common\condition.h =====

﻿#pragma once

#include "utility.h"
#include "error.h"

#include <string>
#include <memory>
#include <functional>
#include <variant>
#include <unordered_map>


enum class Operator {
    // 比较运算符
    EQUAL,          // ==
    NOT_EQUAL,      // !=
    GREATER,        // >
    GREATER_EQUAL,  // >=
    LESS,           // <
    LESS_EQUAL,     // <=
    INCLUDE,             // in

    // 算术运算符
    ADD,            // +
    SUBTRACT,       // -
    MULTIPLY,       // *
    DIVIDE,         // /
    MODULO,         // %
    EXPONENT,       // ^

    // 逻辑运算符
    LOGICAL_AND,    // &&
    LOGICAL_OR      // ||
};

enum class UnaryOperator {
    NEGATE,         // 负号 -
    LOGICAL_NOT     // 逻辑非 !
};

using ValueType = std::variant<int, double, bool, std::string>;

class Expression {
public:
    virtual ~Expression() = default;

    virtual ValueType Evaluate(std::function<ValueType(const std::string&)> getValue) const = 0;
};

class Condition {
public:
    bool ParseCondition(const std::string& conditionStr);

    bool EvaluateBool(std::function<ValueType(const std::string&)> getValue) const;
	ValueType EvaluateValue(std::function<ValueType(const std::string&)> getValue) const;

private:
    std::shared_ptr<Expression> root;

    std::vector<std::string> Tokenize(const std::string& expr);
    std::shared_ptr<Expression> ParseExpression(const std::vector<std::string>& tokens);
    std::vector<std::string> InfixToPostfix(const std::vector<std::string>& infix);
    std::shared_ptr<Expression> ParsePostfix(const std::vector<std::string>& postfix);
    bool IsOperator(const std::string& token);
    bool HigherPrecedence(const std::string& op1, const std::string& op2);
    int GetPrecedence(const std::string& op);
    bool RightAssociative(const std::string& op);
    Operator GetOperator(const std::string& token);
    std::shared_ptr<Expression> ParseOperand(const std::string& token);
    std::shared_ptr<Expression> ParseConstant(const std::string& token);
    bool OperatorChar(char c);
};

bool IsOperatorChar(char c);
bool IsSpaceChar(char c);
bool IsIdentifierChar(char c);

std::string ToString(const ValueType& value);
ValueType FromString(const std::string& s);


// ===== .\Dependence\common\error.cpp =====

﻿#include "error.h"


using namespace std;

ExceptionBase::ExceptionBase(const string& message,
    const string& file,
    int line,
    const string& function) noexcept
    : m_message(message)
    , m_file(file)
    , m_line(line)
    , m_function(function) {
    formatWhat();
}

const char* ExceptionBase::what() const noexcept {
    return m_what.data();
}

string ExceptionBase::GetDetailedInfo() const {
    ostringstream oss;
    oss << "Exception: " << m_message << "\n"
        << "File: " << m_file << "\n"
        << "Line: " << m_line << "\n"
        << "Function: " << (m_function.empty() ? "Unknown" : m_function);
    return oss.str();
}

void ExceptionBase::formatWhat() {
    m_what = m_message + " [at " + m_file + ":" + to_string(m_line) + "]";
    if (!m_function.empty()) {
        m_what += " in " + m_function;
    }
}

// ===== .\Dependence\common\error.h =====

﻿#pragma once

#include <string>
#include <sstream>
#include <exception>


class ExceptionBase : public std::exception {
public:
    ExceptionBase(const std::string& message,
        const std::string& file,
        int line,
        const std::string& function = "") noexcept;

    virtual ~ExceptionBase() noexcept = default;

    // 获取报错
    const char* what() const noexcept override;
    virtual std::string GetDetailedInfo() const;
    const std::string& getMessage() const noexcept { return m_message; }
    const std::string& getFile() const noexcept { return m_file; }
    int getLine() const noexcept { return m_line; }
    const std::string& getFunction() const noexcept { return m_function; }

protected:
    virtual void formatWhat();

    std::string m_message;
    std::string m_file;
    int m_line;
    std::string m_function;
    std::string m_what;
};

class NullPointerException : public ExceptionBase {
public:
    using ExceptionBase::ExceptionBase;
};

class CommandException : public ExceptionBase {
public:
    using ExceptionBase::ExceptionBase;
};

class InvalidArgumentException : public ExceptionBase {
public:
    using ExceptionBase::ExceptionBase;
};

class InvalidConfigException : public ExceptionBase {
public:
    using ExceptionBase::ExceptionBase;
};

class ArithmeticException : public ExceptionBase {
    using ExceptionBase::ExceptionBase;
};

class IOException : public ExceptionBase {
public:
    using ExceptionBase::ExceptionBase;
};

class OutOfRangeException : public ExceptionBase {
    using ExceptionBase::ExceptionBase;
};

class NetworkException : public ExceptionBase {
    using ExceptionBase::ExceptionBase;
};

class MemoryException : public ExceptionBase {
    using ExceptionBase::ExceptionBase;
};

class JsonFormatException : public ExceptionBase {
    using ExceptionBase::ExceptionBase;
};

template<typename ExceptionClass>
[[noreturn]] void ThrowException(const std::string& message,
    const char* file,
    int line,
    const char* function = "") {
    throw ExceptionClass(message, file, line, function);
}

#define THROW_EXCEPTION(ExceptionClass, message) \
    ThrowException<ExceptionClass>(message, __FILE__, __LINE__, __FUNCTION__)

// ===== .\Dependence\common\plot.cpp =====

﻿#include "error.h"
#include "plot.h"

#include <cmath>
#include <utility>
#include <algorithm>


using namespace std;

Node::Node(float x, float y) : posX(x), posY(y) {

}

float Node::GetX() const {
    return posX;
}

float Node::GetY() const {
    return posY;
}

Connection::Connection(Node n1, Node n2) : vertices(n1, n2) {

}

Node Connection::GetV1() const {
    return vertices.first;
}

Node Connection::GetV2() const {
    return vertices.second;
}

Plot::Plot() : Rect(), rotation(0.f) {

}

Plot::Plot(float x, float y, float w, float h, float r) : Rect(x, y, w, h), rotation(r) {

}

Plot::Plot(Node n1, Node n2, Node n3) {
    SetPosition(n1, n2, n3);
}

Plot::Plot(Node n1, Node n2, Node n3, Node n4) {
    SetPosition(n1, n2, n3, n4);
}

float Plot::GetRotation() const {
	return rotation;
}

void Plot::SetRotation(float r) {
    rotation = r;
}

AREA_TYPE Plot::GetArea() const {
    return area;
}

void Plot::SetArea(AREA_TYPE area) {
    this->area = area;
}

pair<float, float> Plot::GetVertex(int idx) const {
	if (idx < 1 || idx > 4) {
		THROW_EXCEPTION(InvalidArgumentException, "Plot has only 4 vertices.\n");
	}

    float hx = sizeX / 2.0f;
    float hy = sizeY / 2.0f;
    float c = cos(rotation);
    float s = sin(rotation);

    switch (idx) {
    case 1: // 右上
        return { posX + hx * c - hy * s,
                 posY + hx * s + hy * c };
    case 2: // 左上
        return { posX - hx * c - hy * s,
                 posY - hx * s + hy * c };
    case 3: // 左下
        return { posX - hx * c + hy * s,
                 posY - hx * s - hy * c };
    case 4: // 右下
        return { posX + hx * c + hy * s,
                 posY + hx * s - hy * c };
    default:
        return { 0.f, 0.f };
    }
}

pair<float, float> Plot::GetPosition(float x, float y) const {
    float cosR = cos(rotation);
    float sinR = sin(rotation);

    float originX = posX - sizeX / 2.0f;
    float originY = posY - sizeY / 2.0f;

    float relativeX = x - sizeX / 2.0f;
    float relativeY = y - sizeY / 2.0f;

    float rotatedX = relativeX * cosR - relativeY * sinR;
    float rotatedY = relativeX * sinR + relativeY * cosR;

    return { posX + rotatedX , posY + rotatedY };
}

void Plot::SetPosition(Node n1, Node n2, Node n3) {
    float x1 = n1.GetX(), y1 = n1.GetY();
    float x2 = n2.GetX(), y2 = n2.GetY();
    float x3 = n3.GetX(), y3 = n3.GetY();

    // 向量 u = p2 - p1, v = p3 - p2
    float ux = x2 - x1, uy = y2 - y1;
    float vx = x3 - x2, vy = y3 - y2;

    // 检查垂直
    float dot = ux * vx + uy * vy;
    const float eps = 1e-5f;
    if (abs(dot) > eps) {
        THROW_EXCEPTION(InvalidArgumentException, "The given edges are not perpendicular.\n");
    }

    // 计算尺寸
    float sx = sqrt(ux * ux + uy * uy);
    float sy = sqrt(vx * vx + vy * vy);

    // 计算中心点：p1 和 p3 的对角线中心
    float cx = (x1 + x3) / 2.0f;
    float cy = (y1 + y3) / 2.0f;

    // 计算旋转角度（p1p2 与 x 轴夹角）
    float rot = atan2(uy, ux);

    // 更新成员变量
    posX = cx;
    posY = cy;
    sizeX = sx;
    sizeY = sy;
    rotation = rot;
    acreage = sx * sy * 100.f;
}
void Plot::SetPosition(Node n1, Node n2, Node n3, Node n4) {
    vector<Node> nodes = { n1, n2, n3, n4 };

    // 计算中心点
    float cx = 0.0f, cy = 0.0f;
    for (const auto& node : nodes) {
        cx += node.GetX();
        cy += node.GetY();
    }
    cx /= 4.0f;
    cy /= 4.0f;

    // 按极角排序（逆时针）
    sort(nodes.begin(), nodes.end(),
        [cx, cy](const Node& a, const Node& b) {
            return atan2(a.GetY() - cy, a.GetX() - cx) <
                atan2(b.GetY() - cy, b.GetX() - cx);
        });

    // 现在 nodes[0], nodes[1], nodes[2], nodes[3] 是逆时针顺序

    // 检查矩形条件
    const float eps = 1e-5f;

    // 计算四个边向量
    float u1x = nodes[1].GetX() - nodes[0].GetX();
    float u1y = nodes[1].GetY() - nodes[0].GetY();
    float u2x = nodes[2].GetX() - nodes[1].GetX();
    float u2y = nodes[2].GetY() - nodes[1].GetY();
    float u3x = nodes[3].GetX() - nodes[2].GetX();
    float u3y = nodes[3].GetY() - nodes[2].GetY();
    float u4x = nodes[0].GetX() - nodes[3].GetX();
    float u4y = nodes[0].GetY() - nodes[3].GetY();

    // 检查邻边垂直（点积为0）
    float dot1 = u1x * u2x + u1y * u2y;
    float dot2 = u2x * u3x + u2y * u3y;
    float dot3 = u3x * u4x + u3y * u4y;
    float dot4 = u4x * u1x + u4y * u1y;

    if (abs(dot1) > eps || abs(dot2) > eps ||
        abs(dot3) > eps || abs(dot4) > eps) {
        THROW_EXCEPTION(InvalidArgumentException, "The given points do not form a rectangle (not all angles are 90 degrees).\n");
    }

    // 检查对边长度相等
    float len1 = sqrt(u1x * u1x + u1y * u1y);
    float len2 = sqrt(u2x * u2x + u2y * u2y);
    float len3 = sqrt(u3x * u3x + u3y * u3y);
    float len4 = sqrt(u4x * u4x + u4y * u4y);

    if (abs(len1 - len3) > eps || abs(len2 - len4) > eps) {
        THROW_EXCEPTION(InvalidArgumentException, "The given points do not form a rectangle (opposite sides not equal).\n");
    }

    // 计算尺寸（取相邻两边长度）
    float sx = len1;
    float sy = len2;

    // 计算旋转角度（使用第一条边 nodes[0]->nodes[1]）
    float rot = atan2(u1y, u1x);

    // 更新成员变量
    posX = cx;
    posY = cy;
    sizeX = sx;
    sizeY = sy;
    rotation = rot;
    acreage = sx * sy * 100.f;
}

const vector<pair<string, shared_ptr<Zone>>> Plot::GetZones() const {
    return zones;
}

const vector<pair<string, shared_ptr<Building>>> Plot::GetBuildings() const {
    return buildings;
}

void Plot::AddZone(string name, shared_ptr<Zone> zone) {
    zones.push_back(make_pair(name, zone));
}

void Plot::AddBuilding(string name, shared_ptr<Building> building) {
    buildings.push_back(make_pair(name, building));
}

shared_ptr<Zone> Plot::GetZone(string name) const {
    for (auto& zone : zones) {
        if(zone.first == name){
            return zone.second;
        }
    }
    return nullptr;
}

shared_ptr<Building> Plot::GetBuilding(string name) const {
    for (auto& building : buildings) {
        if (building.first == name) {
            return building.second;
        }
    }
    return nullptr;
}

void Plot::RemoveZone(string name) {
    for (auto it = zones.begin(); it != zones.end(); ) {
        if(it->first == name){
            it = zones.erase(it);
        }
        else {
            ++it;
        }
    }
}

void Plot::RemoveBuilding(string name) {
    for (auto it = buildings.begin(); it != buildings.end(); ) {
        if (it->first == name) {
            it = buildings.erase(it);
        }
        else {
            ++it;
        }
    }
}


// ===== .\Dependence\common\plot.h =====

﻿#pragma once

#include "../map/zone_base.h"
#include "../map/building_base.h"

#include "utility.h"
#include "rect.h"

#include <vector>
#include <unordered_map>


class Zone;
class Building;

class Node {
public:
	Node(float x, float y);
	~Node() = default;

	float GetX() const;
	float GetY() const;

private:
	float posX, posY;
};

class Connection {
public:
	Connection(Node n1, Node n2);
	~Connection() = default;

	Node GetV1() const;
	Node GetV2() const;

private:
	std::pair<Node, Node> vertices;
};

enum AREA_TYPE {
	AREA_GREEN,
	AREA_RESIDENTIAL_HIGH,
	AREA_RESIDENTIAL_MIDDLE,
	AREA_RESIDENTIAL_LOW,
	AREA_COMMERCIAL_HIGH,
	AREA_COMMERCIAL_MIDDLE,
	AREA_COMMERCIAL_LOW,
	AREA_INDUSTRIAL_HIGH,
	AREA_INDUSTRIAL_MIDDLE,
	AREA_INDUSTRIAL_LOW,
	AREA_OFFICIAL_HIGH,
	AREA_OFFICIAL_MIDDLE,
	AREA_OFFICIAL_LOW,
};

class Plot : public Rect {
public:
	Plot();
	Plot(float x, float y, float w, float h, float r);
	Plot(Node n1, Node n2, Node n3);
	Plot(Node n1, Node n2, Node n3, Node n4);

	// 获取/设置属性
	float GetRotation() const;
	void SetRotation(float r);
	AREA_TYPE GetArea() const;
	void SetArea(AREA_TYPE area);

	// 世界坐标变换
	std::pair<float, float> GetVertex(int idx) const;
	std::pair<float, float> GetPosition(float x, float y) const;

	// 通过逆时针顺序三个顶点设置矩形
	void SetPosition(Node n1, Node n2, Node n3);

	// 通过顺序无关四个顶点设置矩形
	void SetPosition(Node n1, Node n2, Node n3, Node n4);

	// 内部Rect管理
	const std::vector<std::pair<std::string, std::shared_ptr<Zone>>> GetZones() const;
	const std::vector<std::pair<std::string, std::shared_ptr<Building>>>GetBuildings() const;
	void AddZone(std::string name, std::shared_ptr<Zone> zone);
	void AddBuilding(std::string name, std::shared_ptr<Building> building);
	std::shared_ptr<Zone> GetZone(std::string name) const;
	std::shared_ptr<Building> GetBuilding(std::string name) const;
	void RemoveZone(std::string name);
	void RemoveBuilding(std::string name);

protected:
	float rotation;
	AREA_TYPE area;

	std::vector<std::pair<std::string, std::shared_ptr<Zone>>> zones;
	std::vector<std::pair<std::string, std::shared_ptr<Building>>> buildings;
};


// ===== .\Dependence\common\rect.cpp =====

﻿#include "rect.h"

#include <algorithm>


using namespace std;

Rect::Rect() : posX(0.f), posY(0.f), sizeX(0.f), sizeY(0.f), acreage(0.f) {

}

Rect::Rect(float x, float y, float w, float h) : posX(x), posY(y), sizeX(w), sizeY(h), acreage(w * h * 100.f) {
    
}

float Rect::GetPosX() const {
    return posX;
}

void Rect::SetPosX(float x) {
    posX = x;
}

float Rect::GetPosY() const {
    return posY;
}

void Rect::SetPosY(float y) {
    posY = y;
}

float Rect::GetSizeX() const {
    return sizeX;
}

void Rect::SetSizeX(float w) {
    sizeX = w;
}

float Rect::GetSizeY() const {
    return sizeY;
}

void Rect::SetSizeY(float h) {
    sizeY = h;
}

float Rect::GetLeft() const {
    return posX - sizeX / 2.f;
}

float Rect::GetRight() const {
    return posX + sizeX / 2.f;
}

float Rect::GetBottom() const {
    return posY - sizeY / 2.f;
}

float Rect::GetTop() const {
    return posY + sizeY / 2.f;
}

void Rect::SetVertices(float x1, float y1, float x2, float y2) {
    if (x1 > x2) {
        swap(x1, x2);
    }
    if (y1 > y2) {
        swap(y1, y2);
    }

    posX = (x1 + x2) / 2.f;
    posY = (y1 + y2) / 2.f;
    sizeX = x2 - x1;
    sizeY = y2 - y1;
}

void Rect::SetPosition(float x, float y, float w, float h) {
    posX = x;
    posY = y;
    sizeX = w;
    sizeY = h;
}

float Rect::GetAcreage() const {
    return acreage;
}

void Rect::SetAcreage(float a) {
    acreage = a;
}


// ===== .\Dependence\common\rect.h =====

﻿#pragma once

class Rect {
public:
	Rect();
	Rect(float x, float y, float w, float h);
	virtual ~Rect() = default;

	// 获取/设置属性
	float GetPosX() const;
	void SetPosX(float x);
	float GetPosY() const;
	void SetPosY(float y);
	float GetSizeX() const;
	void SetSizeX(float w);
	float GetSizeY() const;
	void SetSizeY(float h);
	float GetLeft() const;
	float GetRight() const;
	float GetBottom() const;
	float GetTop() const;
	void SetVertices(float x1, float y1, float x2, float y2);
	void SetPosition(float x, float y, float w, float h);
	float GetAcreage() const;
	void SetAcreage(float a);

protected:
	float posX, posY;
	float sizeX, sizeY;

	float acreage;
};


// ===== .\Dependence\common\utility.cpp =====

﻿#include "utility.h"

#include <ctime>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <stdexcept>
#include <cmath>
#include <random>
#include <regex>


using namespace std;

void debugf(LPCSTR format, ...) {
    va_list args;
    va_start(args, format);
    int len = _vscprintf(format, args);
    std::vector<char> buf(len + 1);
    vsprintf_s(buf.data(), buf.size(), format, args);
    OutputDebugStringA(buf.data());
    va_end(args);
}

int GetRandom(int range) {
	if (range <= 0)return 0;

	mt19937 rng(random_device{}());
	uniform_int_distribution<int> dist(0, range - 1);
	int ret = dist(rng);

	return ret;
}


Time::Time(bool online) {
    if (online) {
        SetToCurrentTime();
    }
}

Time::Time(int y, int mon, int d, int h, int min, int s, int ms)
    : year(y), month(mon), day(d), hour(h), minute(min), second(s), millisecond(ms) {
    Validate();
}

Time::Time(string time) {
    // 移除字符串前后的空白字符
    time.erase(0, time.find_first_not_of(" \t\n\r\f\v"));
    time.erase(time.find_last_not_of(" \t\n\r\f\v") + 1);

    // 如果字符串为空，设置为当前时间
    if (time.empty()) {
        return;
    }

    // 尝试匹配 ISO 8601 格式: YYYY-MM-DD HH:MM:SS.sss
    regex iso_pattern(R"(^(\d{4})-(\d{1,2})-(\d{1,2})(?:[T ](\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?)?$)");
    smatch match;

    if (regex_match(time, match, iso_pattern)) {
        year = stoi(match[1]);
        month = stoi(match[2]);
        day = stoi(match[3]);

        // 如果有时间部分
        if (match[4].matched) {
            hour = stoi(match[4]);
            minute = stoi(match[5]);
            second = stoi(match[6]);

            if (match[7].matched) {
                millisecond = stoi(match[7]);
                // 补齐毫秒位数
                if (match[7].length() == 1) millisecond *= 100;
                else if (match[7].length() == 2) millisecond *= 10;
            }
        }

        Validate();
        return;
    }

    // 尝试匹配常见的中文格式: YYYY年MM月DD日 HH:MM:SS
    regex chinese_pattern(R"(^(\d{4})年(\d{1,2})月(\d{1,2})日(?:\s+(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?)?$)");

    if (regex_match(time, match, chinese_pattern)) {
        year = stoi(match[1]);
        month = stoi(match[2]);
        day = stoi(match[3]);

        if (match[4].matched) {
            hour = stoi(match[4]);
            minute = stoi(match[5]);
            second = stoi(match[6]);

            if (match[7].matched) {
                millisecond = stoi(match[7]);
                if (match[7].length() == 1) millisecond *= 100;
                else if (match[7].length() == 2) millisecond *= 10;
            }
        }

        Validate();
        return;
    }

    // 尝试匹配美国格式: MM/DD/YYYY HH:MM:SS
    regex us_pattern(R"(^(\d{1,2})/(\d{1,2})/(\d{4})(?:\s+(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?)?$)");

    if (regex_match(time, match, us_pattern)) {
        month = stoi(match[1]);
        day = stoi(match[2]);
        year = stoi(match[3]);

        if (match[4].matched) {
            hour = stoi(match[4]);
            minute = stoi(match[5]);
            second = stoi(match[6]);

            if (match[7].matched) {
                millisecond = stoi(match[7]);
                if (match[7].length() == 1) millisecond *= 100;
                else if (match[7].length() == 2) millisecond *= 10;
            }
        }

        Validate();
        return;
    }

    // 尝试只包含时间的格式: HH:MM:SS.sss
    regex day_pattern(R"(^(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d{1,3}))?$)");

    if (regex_match(time, match, day_pattern)) {
        hour = stoi(match[1]);
        minute = stoi(match[2]);
        second = stoi(match[3]);

        if (match[4].matched) {
            millisecond = stoi(match[4]);
            if (match[4].length() == 1) millisecond *= 100;
            else if (match[4].length() == 2) millisecond *= 10;
        }

        Validate();
        return;
    }

    // 如果所有格式都不匹配，抛出异常
    throw invalid_argument("无法解析时间字符串: " + time);
}

bool Time::IsValid() const {
    return year > 0;
}

void Time::SetYear(int y) {
    year = y; Validate();
}
void Time::SetMonth(int m) {
    month = m; Validate();
}
void Time::SetDay(int d) {
    day = d; Validate();
}
void Time::SetHour(int h) {
    hour = h; Validate();
}
void Time::SetMinute(int m) {
    minute = m; Validate();
}
void Time::SetSecond(int s) {
    second = s; Validate();
}
void Time::SetMillisecond(int ms) {
    millisecond = ms; Validate();
}

void Time::SetDate(int y, int m, int d) {
    year = y; month = m; day = d;
    Validate();
}

void Time::SetTime(int h, int m, int s, int ms) {
    hour = h; minute = m; second = s; millisecond = ms;
    Validate();
}

int Time::GetYear() const {
    return year;
}
int Time::GetMonth() const {
    return month;
}
int Time::GetDay() const {
    return day;
}
int Time::GetHour() const {
    return hour;
}
int Time::GetMinute() const {
    return minute;
}
int Time::GetSecond() const {
    return second;
}
int Time::GetMillisecond() const {
    return millisecond;
}

void Time::SetToCurrentTime() {
    auto now = chrono::system_clock::now();
    auto now_time = chrono::system_clock::to_time_t(now);
    auto ms = chrono::duration_cast<chrono::milliseconds>(
        now.time_since_epoch()) % 1000;

    struct tm tm;
    time_t t = time(nullptr);
    if (localtime_s(&tm, &t) == 0) {
        year = tm.tm_year + 1900;
        month = tm.tm_mon + 1;
        day = tm.tm_mday;
        hour = tm.tm_hour;
        minute = tm.tm_min;
        second = tm.tm_sec;
        millisecond = static_cast<int>(ms.count());
    }
}

void Time::AddYears(int years) {
    year += years;
}

void Time::AddMonths(int months) {
    month += months;
    while (month > 12) {
        month -= 12;
        year++;
    }
    while (month < 1) {
        month += 12;
        year--;
    }
}

void Time::AddDays(int days) {
    day += days;
    while (day > DaysInMonth(year, month)) {
        day -= DaysInMonth(year, month);
        AddMonths(1);
    }
    while (day < 1) {
        AddMonths(-1);
        day += DaysInMonth(year, month);
    }
}

void Time::AddHours(int hours) {
    hour += hours;
    NormalizeTime();
}

void Time::AddMinutes(int minutes) {
    minute += minutes;
    NormalizeTime();
}

void Time::AddSeconds(int seconds) {
    second += seconds;
    NormalizeTime();
}

void Time::AddMilliseconds(int ms) {
    millisecond += ms;
    NormalizeTime();
}

string Time::ToString() const {
    return Format("YYYY-MM-DD HH:mm:ss.zzz");
}

string Time::Format(const string& fmt) const {
    ostringstream oss;
    for (size_t i = 0; i < fmt.size(); ++i) {
        if (fmt[i] == 'Y') {
            if (fmt.substr(i, 4) == "YYYY") {
                oss << setw(4) << setfill('0') << year;
                i += 3;
            }
            else if (fmt.substr(i, 2) == "YY") {
                oss << setw(2) << setfill('0') << (year % 100);
                i += 1;
            }
        }
        else if (fmt[i] == 'M') {
            if (fmt.substr(i, 2) == "MM") {
                oss << setw(2) << setfill('0') << month;
                i += 1;
            }
        }
        else if (fmt[i] == 'D') {
            if (fmt.substr(i, 2) == "DD") {
                oss << setw(2) << setfill('0') << day;
                i += 1;
            }
        }
        else if (fmt[i] == 'H') {
            if (fmt.substr(i, 2) == "HH") {
                oss << setw(2) << setfill('0') << hour;
                i += 1;
            }
        }
        else if (fmt[i] == 'm') {
            if (fmt.substr(i, 2) == "mm") {
                oss << setw(2) << setfill('0') << minute;
                i += 1;
            }
        }
        else if (fmt[i] == 's') {
            if (fmt.substr(i, 2) == "ss") {
                oss << setw(2) << setfill('0') << second;
                i += 1;
            }
        }
        else if (fmt[i] == 'z') {
            if (fmt.substr(i, 3) == "zzz") {
                oss << setw(3) << setfill('0') << millisecond;
                i += 2;
            }
        }
        else {
            oss << fmt[i];
        }
    }
    return oss.str();
}

bool Time::operator==(const Time& other) const {
    return year == other.year &&
        month == other.month &&
        day == other.day &&
        hour == other.hour &&
        minute == other.minute &&
        second == other.second &&
        millisecond == other.millisecond;
}

bool Time::operator<(const Time& other) const {
    if (year != other.year) return year < other.year;
    if (month != other.month) return month < other.month;
    if (day != other.day) return day < other.day;
    if (hour != other.hour) return hour < other.hour;
    if (minute != other.minute) return minute < other.minute;
    if (second != other.second) return second < other.second;
    return millisecond < other.millisecond;
}

bool Time::operator>(const Time& other) const { return other < *this; }
bool Time::operator<=(const Time& other) const { return !(*this > other); }
bool Time::operator>=(const Time& other) const { return !(*this < other); }
bool Time::operator!=(const Time& other) const { return !(*this == other); }

Time Time::operator+(const Time& other) const {
    Time result = *this;
    result.AddYears(other.year);
    result.AddMonths(other.month);
    result.AddDays(other.day);
    result.AddHours(other.hour);
    result.AddMinutes(other.minute);
    result.AddSeconds(other.second);
    result.AddMilliseconds(other.millisecond);
    return result;
}

Time Time::operator-(const Time& other) const {
    Time result = *this;
    result.AddYears(-other.year);
    result.AddMonths(-(other.month - 1));
    result.AddDays(-(other.day - 1));
    result.AddHours(-other.hour);
    result.AddMinutes(-other.minute);
    result.AddSeconds(-other.second);
    result.AddMilliseconds(-other.millisecond);
    return result;
}

Time& Time::operator+=(const Time& other) {
    *this = *this + other;
    return *this;
}

Time& Time::operator-=(const Time& other) {
    *this = *this - other;
    return *this;
}

double Time::DifferenceInSeconds(const Time& other) const {
    if (*this == other) return 0.0;

    const Time* earlier = this;
    const Time* later = &other;
    bool inverted = false;
    if (*this > other) {
        earlier = &other;
        later = this;
        inverted = true;
    }

    int yearDays = 0;
    if (earlier->year != later->year) {
        yearDays = DaysBetweenYears(earlier->year, later->year);
    }

    int earlierDayOfYear = earlier->OrdinalDate();
    int laterDayOfYear = later->OrdinalDate();

    int dayDifference = laterDayOfYear - earlierDayOfYear + yearDays;

    int secondsEarlier = earlier->hour * 3600 + earlier->minute * 60 + earlier->second;
    int secondsLater = later->hour * 3600 + later->minute * 60 + later->second;

    double totalSeconds = dayDifference * 86400.0 + (secondsLater - secondsEarlier);

    totalSeconds += (later->millisecond - earlier->millisecond) / 1000.0;

    return inverted ? totalSeconds : -totalSeconds;
}

bool Time::IsLeapYear() const {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int Time::DayOfWeek() const {
    int m = month;
    int y = year;
    if (m < 3) {
        m += 12;
        y--;
    }
    int q = day;
    int k = y % 100;
    int j = y / 100;
    int h = (q + 13 * (m + 1) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;
    return (h + 6) % 7;
}

string Time::DayOfWeekName() const {
    static const string names[] = {
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    };
    return names[DayOfWeek()];
}

void Time::Validate() const {
    if (month < 1 || month > 12)
        throw out_of_range("Month must be between 1-12.\n");
    if (day < 1 || day > DaysInMonth(year, month))
        throw out_of_range("Invalid day for given month and year.\n");
    if (hour < 0 || hour > 23)
        throw out_of_range("Hour must be between 0-23.\n");
    if (minute < 0 || minute > 59)
        throw out_of_range("Minute must be between 0-59.\n");
    if (second < 0 || second > 59)
        throw out_of_range("Second must be between 0-59.\n");
    if (millisecond < 0 || millisecond > 999)
        throw out_of_range("Millisecond must be between 0-999.\n");
}

int Time::DaysInMonth(int year, int month) {
    static const int days[] = {
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    };
    if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))) {
        return 29;
    }
    return days[month - 1];
}

int Time::DaysInYear(int year) {
    return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) ? 366 : 365;
}

int Time::DaysBetweenYears(int startYear, int endYear) {
    if (startYear > endYear) return -DaysBetweenYears(endYear, startYear);

    int totalDays = 0;
    for (int year = startYear; year < endYear; year++) {
        totalDays += DaysInYear(year);
    }
    return totalDays;
}

int Time::DaysBetween(const Time& start, const Time& end) {
    // 确保开始日期不晚于结束日期
    if (start > end) {
        return -DaysBetween(end, start);
    }

    // 计算年份差的天数
    int totalDays = 0;
    for (int year = start.GetYear(); year < end.GetYear(); year++) {
        totalDays += Time::DaysInYear(year);
    }

    // 计算开始日期在当年的天数
    Time startYearStart(start.GetYear(), 1, 1);
    int startDays = (start - startYearStart).GetDay();

    // 计算结束日期在当年的天数
    Time endYearStart(end.GetYear(), 1, 1);
    int endDays = (end - endYearStart).GetDay();

    return totalDays + endDays - startDays;
}

void Time::NormalizeTime() {
    while (millisecond >= 1000) {
        millisecond -= 1000;
        second++;
    }
    while (millisecond < 0) {
        millisecond += 1000;
        second--;
    }

    while (second >= 60) {
        second -= 60;
        minute++;
    }
    while (second < 0) {
        second += 60;
        minute--;
    }

    while (minute >= 60) {
        minute -= 60;
        hour++;
    }
    while (minute < 0) {
        minute += 60;
        hour--;
    }

    while (hour >= 24) {
        hour -= 24;
        day++;
    }
    while (hour < 0) {
        hour += 24;
        day--;
    }

    while (day > DaysInMonth(year, month)) {
        day -= DaysInMonth(year, month);
        month++;
        if (month > 12) {
            month = 1;
            year++;
        }
    }
    while (day < 1) {
        month--;
        if (month < 1) {
            month = 12;
            year--;
        }
        day += DaysInMonth(year, month);
    }

    Validate();
}

int Time::OrdinalDate() const {
    int days = day;
    for (int m = 1; m < month; m++) {
        days += DaysInMonth(year, m);
    }
    return days;
}

Time GetRandom(Time begin, Time end) {
    // 矫正起始与结束时间
    if (begin > end) {
        swap(begin, end);
    }
    else if (begin == end) {
        return begin;
    }

    // 将时间归一化到当天0点
    begin.SetTime(0, 0, 0, 0);
    end.SetTime(0, 0, 0, 0);

    // 计算总天数
    int totalDays = Time::DaysBetween(begin, end) + 1;

    // 生成随机偏移天数
    int randomDays = GetRandom(totalDays);

    // 创建结果时间
    Time result = begin;
    result.AddDays(randomDays);

    return result;
}

// ===== .\Dependence\common\utility.h =====

﻿#pragma once

#include <string>
#include <memory>
#include <set>
#include <mutex>
#include <codecvt>
#include <locale>
#include <exception>

#include <windows.h>
#include <strsafe.h>

#define REPLACE_PATH(path) (path)

#ifdef _DEBUG
#define MOD_TEST
#endif // DEBUG


// 调试控制台输出
void debugf(LPCSTR format, ...);

// 获取[0, range - 1]的随机整数
int GetRandom(int range);

class Time {
public:
    Time() = default;
    Time(bool online);
    Time(int y, int mon = 1, int d = 1, int h = 0, int min = 0, int s = 0, int ms = 0);
    Time(std::string time);

    // 判断是否为空
    bool IsValid() const;

    // 获取/设置时间
    int GetYear() const;
    int GetMonth() const;
    int GetDay() const;
    int GetHour() const;
    int GetMinute() const;
    int GetSecond() const;
    int GetMillisecond() const;
    void SetYear(int y);
    void SetMonth(int m);
    void SetDay(int d);
    void SetHour(int h);
    void SetMinute(int m);
    void SetSecond(int s);
    void SetMillisecond(int ms);
    void SetDate(int y, int m, int d);
    void SetTime(int h, int m, int s, int ms = 0);

    // 使用在线时间
    void SetToCurrentTime();

    // 时间偏移
    void AddYears(int years);
    void AddMonths(int months);
    void AddDays(int days);
    void AddHours(int hours);
    void AddMinutes(int minutes);
    void AddSeconds(int seconds);
    void AddMilliseconds(int ms);

    // 输出时间
    std::string ToString() const;
    std::string Format(const std::string& fmt) const;

    // 时间比较与计算
    bool operator==(const Time& other) const;
    bool operator<(const Time& other) const;
    bool operator>(const Time& other) const;
    bool operator<=(const Time& other) const;
    bool operator>=(const Time& other) const;
    bool operator!=(const Time& other) const;
    Time operator+(const Time& other) const;
    Time operator-(const Time& other) const;
    Time& operator+=(const Time& other);
    Time& operator-=(const Time& other);
    double DifferenceInSeconds(const Time& other) const;

    // 日期属性
    bool IsLeapYear() const;
    int DayOfWeek() const;
    std::string DayOfWeekName() const;

    // 天数计算
    static int DaysInMonth(int year, int month);
    static int DaysInYear(int year);
    static int DaysBetweenYears(int startYear, int endYear);
    static int DaysBetween(const Time& start, const Time& end);

private:
    int year = 0;
    int month = 1;
    int day = 1;
    int hour = 0;
    int minute = 0;
    int second = 0;
    int millisecond = 0;

    // 检查各项数值范围
    void Validate() const;

    // 时间进位
    void NormalizeTime();

    // 当前为当年第几天
    int OrdinalDate() const;
};

// 时间范围内随机采样
Time GetRandom(Time begin, Time end);


// ===== .\Dependence\map\building_base.cpp =====

﻿#include "../common/error.h"

#include "building_base.h"

#include <filesystem>
#include <string>
#include <fstream>


using namespace std;

Facility::Facility(FACILITY_TYPE type, float x, float y, float w, float h)
    : Rect(x, y, w, h), type(type) {

}

Facility::FACILITY_TYPE Facility::getType() const {
    return type;
}

Floor::Floor(int level, float width, float height) : level(level) {
    SetVertices(0, 0, width, height);
}

Floor::~Floor() {

}

void Floor::AddFacility(Facility facility) {
    facilities.push_back(facility);
}

void Floor::AddRow(pair<Rect, int> row) {
    rows.push_back(row);
}

void Floor::AddRoom(pair<Rect, int> room) {
    rooms.push_back(room);
}

int Floor::GetLevel() const {
    return level;
}

vector<Facility>& Floor::GetFacilities() {
    return facilities;
}

vector<pair<Rect, int>>& Floor::GetRows() {
    return rows;
}

vector<pair<Rect, int>>& Floor::GetRooms() {
    return rooms;
}

void Building::SetParent(shared_ptr<Plot> plot) {
    parentPlot = plot;
}

void Building::SetParent(shared_ptr<Zone> zone) {
    parentZone = zone;
}

shared_ptr<Plot> Building::GetParentPlot() const {
    return parentPlot;
}

shared_ptr<Zone> Building::GetParentZone() const {
    return parentZone;
}

int Building::GetOwner() const {
    return ownerId;
}

void Building::SetOwner(int id) {
    ownerId = id;
}

bool Building::GetStateOwned() const {
    return stateOwned;
}

void Building::SetStateOwned(bool state) {
    stateOwned = state;
}

int Building::GetLayers() const {
    return layers;
}

int Building::GetBasements() const {
    return basements;
}

vector<shared_ptr<Component>>& Building::GetComponents() {
    return components;
}

vector<shared_ptr<Room>>& Building::GetRooms() {
    return rooms;
}

shared_ptr<Floor> Building::GetFloor(int level) const {
    if (basements + level >= 0 && basements + level < floors.size())
        return floors[basements + level];
    else return nullptr;
}

void Building::FinishInit() {
    floors = vector<shared_ptr<Floor>>(basements + layers);
}

unique_ptr<Layout> Building::ReadTemplates(string path) {
    if (!filesystem::exists(REPLACE_PATH(path))) {
        THROW_EXCEPTION(IOException, "Path does not exist: " + path + ".\n");
    }

    auto layout = make_unique<Layout>();

    for (const auto& entry : filesystem::directory_iterator(path)) {
        if (entry.is_regular_file()) {
            string filename = entry.path().filename().string();
            string basename = filename.substr(0, filename.length() - 4);
            string extension = filename.substr(filename.length() - 3, filename.length());
            if (extension != "txt")continue;

            ifstream fin(entry.path());
            if (!fin.is_open()) {
                THROW_EXCEPTION(IOException, "Failed to open file: " + path + ".\n");
            }

            // 初始化当前文件的模板存储
            layout->templateFacilities[basename] = vector<vector<pair<Facility::FACILITY_TYPE, vector<float>>>>(4);
            layout->templateRows[basename] = vector<vector<pair<FACE_DIRECTION, vector<float>>>>(4);
            layout->templateRooms[basename] = vector<vector<pair<FACE_DIRECTION, vector<float>>>>(4);

            string type;
            while (fin >> type) {
                // 处理注释行
                if (type == "#") {
                    fin.ignore((numeric_limits<streamsize>::max)(), '\n');
                    continue;
                }

                // 处理设施
                if (type == "corridor" || type == "stair" || type == "elevator") {
                    vector<float> params(8);
                    bool readError = false;

                    for (int i = 0; i < 8; i++) {
                        if (!(fin >> params[i])) {
                            readError = true;
                            break;
                        }
                    }

                    if (readError) {
                        THROW_EXCEPTION(InvalidConfigException, "Incomplete parameters for " + type +
                            " in file: " + filename + "\n");
                    }

                    // 转换为枚举类型
                    Facility::FACILITY_TYPE facType;
                    if (type == "corridor")facType = Facility::FACILITY_CORRIDOR;
                    else if (type == "stair")facType = Facility::FACILITY_STAIR;
                    else facType = Facility::FACILITY_ELEVATOR;

                    layout->templateFacilities[basename][0].push_back({ facType, InverseParams(params, 0) });
                    layout->templateFacilities[basename][1].push_back({ facType, InverseParams(params, 1) });
                    layout->templateFacilities[basename][2].push_back({ facType, InverseParams(params, 2) });
                    layout->templateFacilities[basename][3].push_back({ facType, InverseParams(params, 3) });
                }
                // 处理房间排
                else if (type == "row") {
                    int directionInt;
                    if (!(fin >> directionInt)) {
                        THROW_EXCEPTION(InvalidConfigException, "Failed to read direction for row in file: " + filename + "\n");
                    }

                    // 验证方向值有效性
                    if (directionInt < 0 || directionInt > 3) {
                        THROW_EXCEPTION(InvalidConfigException, "Invalid direction value " + to_string(directionInt) +
                            " in file: " + filename + "\n");
                    }
                    FACE_DIRECTION direction = static_cast<FACE_DIRECTION>(directionInt);

                    vector<float> params(8);
                    bool readError = false;
                    for (int i = 0; i < 8; i++) {
                        if (!(fin >> params[i])) {
                            readError = true;
                            break;
                        }
                    }

                    if (readError) {
                        THROW_EXCEPTION(InvalidConfigException, "Incomplete parameters for row in file: " + filename + "\n");
                    }

                    layout->templateRows[basename][0].push_back({ 
                        (FACE_DIRECTION)InverseDirection(direction, 0), InverseParams(params, 0) });
                    layout->templateRows[basename][1].push_back({ 
                        (FACE_DIRECTION)InverseDirection(direction, 1), InverseParams(params, 1) });
                    layout->templateRows[basename][2].push_back({ 
                        (FACE_DIRECTION)InverseDirection(direction, 2), InverseParams(params, 2) });
                    layout->templateRows[basename][3].push_back({ 
                        (FACE_DIRECTION)InverseDirection(direction, 3), InverseParams(params, 3) });
                }
                // 处理房间
                else if (type == "room") {
                    int directionInt;
                    if (!(fin >> directionInt)) {
                        THROW_EXCEPTION(InvalidConfigException, "Failed to read direction for room in file: " + filename + "\n");
                    }

                    // 验证方向值有效性
                    if (directionInt < 0 || directionInt > 3) {
                        THROW_EXCEPTION(InvalidConfigException, "Invalid direction value " + to_string(directionInt) +
                            " in file: " + filename + "\n");
                    }
                    FACE_DIRECTION direction = static_cast<FACE_DIRECTION>(directionInt);

                    vector<float> params(8);
                    bool readError = false;
                    for (int i = 0; i < 8; i++) {
                        if (!(fin >> params[i])) {
                            readError = true;
                            break;
                        }
                    }

                    if (readError) {
                        THROW_EXCEPTION(InvalidConfigException, "Incomplete parameters for room in file: " + filename + "\n");
                    }

                    layout->templateRooms[basename][0].push_back({
                        (FACE_DIRECTION)InverseDirection(direction, 0), InverseParams(params, 0) });
                    layout->templateRooms[basename][1].push_back({
                        (FACE_DIRECTION)InverseDirection(direction, 1), InverseParams(params, 1) });
                    layout->templateRooms[basename][2].push_back({
                        (FACE_DIRECTION)InverseDirection(direction, 2), InverseParams(params, 2) });
                    layout->templateRooms[basename][3].push_back({
                        (FACE_DIRECTION)InverseDirection(direction, 3), InverseParams(params, 3) });
                }
                // 处理未知类型
                else {
                    fin.ignore((numeric_limits<streamsize>::max)(), '\n');
                    THROW_EXCEPTION(InvalidConfigException, "Unknown type identifier '" + type +
                        "' in file: " + filename + "\n");\
                }
            }
        }
    }

    return layout;
}

void Building::ReadFloor(int level, float width, float height, int face, string name, unique_ptr<Layout>& layout) {
    auto floor = make_shared<Floor>(level, width, height);

    for (auto facility : layout->templateFacilities[name][face]) {
        float x = (facility.second[0] * width + facility.second[1] + facility.second[4] * width + facility.second[5]) / 2.f;
        float y = (facility.second[2] * height + facility.second[3] + facility.second[6] * height + facility.second[7]) / 2.f;
        float w = facility.second[4] * width + facility.second[5] - facility.second[0] * width - facility.second[1];
        float h = facility.second[6] * height + facility.second[7] - facility.second[2] * height - facility.second[3];
        floor->AddFacility(Facility(facility.first, x, y, w, h));
    }

    for (auto row : layout->templateRows[name][face]) {
        float x = (row.second[0] * width + row.second[1] + row.second[4] * width + row.second[5]) / 2.f;
        float y = (row.second[2] * height + row.second[3] + row.second[6] * height + row.second[7]) / 2.f;
        float w = row.second[4] * width + row.second[5] - row.second[0] * width - row.second[1];
        float h = row.second[6] * height + row.second[7] - row.second[2] * height - row.second[3];
        floor->AddRow(make_pair(Rect(x, y, w, h), row.first));
    }

    for (auto room : layout->templateRooms[name][face]) {
        float x = (room.second[0] * width + room.second[1] + room.second[4] * width + room.second[5]) / 2.f;
        float y = (room.second[2] * height + room.second[3] + room.second[6] * height + room.second[7]) / 2.f;
        float w = room.second[4] * width + room.second[5] - room.second[0] * width - room.second[1];
        float h = room.second[6] * height + room.second[7] - room.second[2] * height - room.second[3];
        floor->AddRoom(make_pair(Rect(x, y, w, h), room.first));
    }

    floors[basements + level] = floor;
}

void Building::ReadFloors(float width, float height, int face, string name, unique_ptr<Layout>& layout) {
    for (int i = 0; i < basements + layers; i++) {
        ReadFloor(i, width, height, face, name, layout);
    }
}

void Building::ReadFloors(float width, float height, int face, vector<string> names, unique_ptr<Layout>& layout) {
    if (names.size() != basements + layers) {
        THROW_EXCEPTION(InvalidArgumentException, "Template number and building layers mismatch.\n");
    }

    for (int i = 0; i < basements + layers; i++) {
        ReadFloor(i, width, height, face, names[i], layout);
    }
}

void Building::AssignRoom(int level, int slot, string name, shared_ptr<Component> component, RoomFactory* factory) {
    shared_ptr<Room> room = factory->CreateRoom(name);
    room->SetLayer(level);
    room->SetPosition(
        floors[basements + level]->GetRooms()[slot].first.GetPosX(),
        floors[basements + level]->GetRooms()[slot].first.GetPosY(),
        floors[basements + level]->GetRooms()[slot].first.GetSizeX(),
        floors[basements + level]->GetRooms()[slot].first.GetSizeY());
    room->SetFace(floors[basements + level]->GetRooms()[slot].second);
    component->AddRoom(room);
    rooms.push_back(room);
}

void Building::ArrangeRow(int level, int slot, string name, float acreage, shared_ptr<Component> component, RoomFactory* factory) {
    auto row = floors[basements + level]->GetRows()[slot];

    float num = row.first.GetAcreage() / acreage;
    if (num - (int)num >= 0.5f)num = num + 1;

    if (row.second == 0 || row.second == 1) {
        float div = row.first.GetSizeY() / (int)num;
        for (int i = 0; i < (int)num; i++) {
            shared_ptr<Room> room = factory->CreateRoom(name);
            room->SetLayer(level);
            room->SetVertices(row.first.GetLeft(), row.first.GetBottom() + div * i,
                row.first.GetRight(), row.first.GetBottom() + div * (i + 1));
            room->SetFace(floors[basements + level]->GetRows()[slot].second);
            component->AddRoom(room);
            rooms.push_back(move(room));
        }
    }
    else {
        float div = row.first.GetSizeX() / (int)num;
        for (int i = 0; i < (int)num; i++) {
            shared_ptr<Room> room = factory->CreateRoom(name);
            room->SetLayer(level);
            room->SetVertices(row.first.GetLeft() + div * i, row.first.GetBottom(),
                row.first.GetLeft() + div * (i + 1), row.first.GetTop());
            room->SetFace(floors[basements + level]->GetRows()[slot].second);
            component->AddRoom(room);
            rooms.push_back(move(room));
        }
    }
}

vector<float> Building::InverseParams(vector<float>& params, int face) {
    if (face < 0 || face >= 4) {
        THROW_EXCEPTION(InvalidArgumentException, "Wrong facing direction.\n");
    }
    auto inversed = params;
    switch (face) {
    case 0:
        inversed[0] = params[2];
        inversed[1] = params[3];
        inversed[2] = params[0];
        inversed[3] = params[1];
        inversed[4] = params[6];
        inversed[5] = params[7];
        inversed[6] = params[4];
        inversed[7] = params[5];
        break;
    case 1:
        inversed[0] = 1.f - params[2];
        inversed[1] = -params[3];
        inversed[2] = 1.f - params[0];
        inversed[3] = -params[1];
        inversed[4] = 1.f - params[6];
        inversed[5] = -params[7];
        inversed[6] = 1.f - params[4];
        inversed[7] = -params[5];
        break;
    case 2:
        break;
    case 3:
        inversed[0] = 1.f - params[0];
        inversed[1] = -params[1];
        inversed[2] = 1.f - params[2];
        inversed[3] = -params[3];
        inversed[4] = 1.f - params[4];
        inversed[5] = -params[5];
        inversed[6] = 1.f - params[6];
        inversed[7] = -params[7];
        break;
    default:
        break;
    }

    return inversed;
}

int Building::InverseDirection(int direction, int face) {
    if (face < 0 || face >= 4) {
        THROW_EXCEPTION(InvalidArgumentException, "Wrong facing direction.\n");
    }
    switch (face) {
    case 0:
        return (direction + 2) % 4;
    case 1:
        if (direction >= 2)return 3 - direction;
        else return direction + 2;
    case 2:
        return direction;
    case 3:
        if (direction >= 2)return -direction;
        else return direction;
    }

    return direction;
}

void BuildingFactory::RegisterBuilding(const string& id, function<unique_ptr<Building>()> creator, vector<float> power) {
    registries[id] = creator;
    configs[id] = false;
    powers[id] = power;
}

unique_ptr<Building> BuildingFactory::CreateBuilding(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool BuildingFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void BuildingFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

const unordered_map<string, vector<float>>& BuildingFactory::GetPowers() const {
    return powers;
}



// ===== .\Dependence\map\building_base.h =====

﻿#pragma once

#include "../common/rect.h"
#include "../common/plot.h"

#include "room_base.h"
#include "component_base.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


enum AREA_TYPE;

class Plot;
class Zone;
class Component;
class Room;

class RoomFactory;

// 建筑方向
enum FACE_DIRECTION {
	FACE_WEST,
	FACE_EAST,
	FACE_NORTH,
	FACE_SOUTH
};
static char faceAbbr[4] = { 'w', 'e', 'n', 's' };

// 走廊&电梯&楼梯
class Facility : public Rect {
public:
	enum FACILITY_TYPE { FACILITY_CORRIDOR, FACILITY_STAIR, FACILITY_ELEVATOR };

	Facility(FACILITY_TYPE type, float x, float y, float w, float h);

	FACILITY_TYPE getType() const;

private:
	FACILITY_TYPE type;
};

// 楼层
class Floor : public Rect {
public:
	Floor(int level, float width, float height);
	~Floor();

	void AddFacility(Facility facility);

	void AddRow(std::pair<Rect, int> row);

	void AddRoom(std::pair<Rect, int> room);

	// 获取楼层
	int GetLevel() const;

	// 访问组件
	std::vector<Facility>& GetFacilities();
	std::vector<std::pair<Rect, int>>& GetRows();
	std::vector<std::pair<Rect, int>>& GetRooms();

private:
	int level;

	std::vector<Facility> facilities;
	std::vector<std::pair<Rect, int>> rows;
	std::vector<std::pair<Rect, int>> rooms;
};

class Layout {
public:
	std::unordered_map<std::string, std::vector<std::vector<std::pair<Facility::FACILITY_TYPE, std::vector<float>>>>> templateFacilities;
	std::unordered_map<std::string, std::vector<std::vector<std::pair<FACE_DIRECTION, std::vector<float>>>>> templateRows;
	std::unordered_map<std::string, std::vector<std::vector<std::pair<FACE_DIRECTION, std::vector<float>>>>> templateRooms;
};

class Building : public Rect {
public:
    Building() = default;
    virtual ~Building() = default;

	// 子类实现方法

    // 动态返回建筑静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 功能区中的建筑权重
    static std::vector<float> GetPower();

    // 建筑面积范围
    virtual float RandomAcreage() const = 0;
    virtual float GetAcreageMin() const = 0;
    virtual float GetAcreageMax() const = 0;

    // 内部房间布局
    virtual void LayoutRooms(RoomFactory *factory, std::unique_ptr<Layout>& layout) = 0;

	// 父类实现方法

	// 关联地块
	void SetParent(std::shared_ptr<Plot> plot);
	void SetParent(std::shared_ptr<Zone> zone);
	std::shared_ptr<Plot> GetParentPlot() const;
	std::shared_ptr<Zone> GetParentZone() const;

	// 获取/设置房东
	int GetOwner() const;
	void SetOwner(int id);
	bool GetStateOwned() const;
	void SetStateOwned(bool state);

	// 获取/设置属性
	int GetLayers() const;
	int GetBasements() const;

	// 获取/设置组织/房间/楼层
	std::vector<std::shared_ptr<Component>>& GetComponents();
	std::vector<std::shared_ptr<Room>>& GetRooms();
	std::shared_ptr<Floor> GetFloor(int level) const;

	// 补充初始化
	void FinishInit();

	// 读入布局模板
	static std::unique_ptr<Layout> ReadTemplates(std::string path);

protected:
	std::shared_ptr<Zone> parentZone;
	std::shared_ptr<Plot> parentPlot;

	bool stateOwned = false;
	int ownerId = -1;

	std::vector<std::shared_ptr<Floor>> floors;
	std::vector<std::shared_ptr<Component>> components;
	std::vector<std::shared_ptr<Room>> rooms;

	int layers = 1;
	int basements = 0;

	// 根据布局文件分配房间
	void ReadFloor(int level, float width, float height, int face, std::string name, std::unique_ptr<Layout>& layout);
	void ReadFloors(float width, float height, int face, std::string name, std::unique_ptr<Layout>& layout);
	void ReadFloors(float width, float height, int face, std::vector<std::string> names, std::unique_ptr<Layout>& layout);
	void AssignRoom(int level, int slot, std::string name, std::shared_ptr<Component> component, RoomFactory* factory);
	void ArrangeRow(int level, int slot, std::string name, float acreage, std::shared_ptr<Component> component, RoomFactory* factory);

	// 建筑中添加组织
	template<class T>
	std::shared_ptr<T> CreateComponent() {
		std::shared_ptr<T> component = std::make_shared<T>();
		components.push_back(component);
		return component;
	}

	// 建筑中添加房间
	template<class T>
	std::shared_ptr<T> CreateRoom(int level, float acreage) {
		std::shared_ptr<T> room = std::make_shared<T>();
		room->SetLayer(level);
		room->SetAcreage(acreage);
		rooms.push_back(room);
		return room;
	}

private:
	static std::vector<float> InverseParams(std::vector<float>& params, int face);
	static int InverseDirection(int direction, int face);
};

class BuildingFactory {
public:
    void RegisterBuilding(const std::string& id,
		std::function<std::unique_ptr<Building>()> creator, std::vector<float> powers);
    std::unique_ptr<Building> CreateBuilding(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    const std::unordered_map<std::string, std::vector<float>>& GetPowers() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Building>()>> registries;
    std::unordered_map<std::string, bool> configs;
    std::unordered_map<std::string, std::vector<float>> powers;
};

// ===== .\Dependence\map\component_base.cpp =====

﻿#include "component_base.h"
#include "building_base.h"


using namespace std;

void Component::SetParent(shared_ptr<Building> building) {
    parentBuilding = building;
}

shared_ptr<Building> Component::GetParent() const {
    return parentBuilding;
}

vector<shared_ptr<Room>>& Component::GetRooms() {
    return rooms;
}

void Component::AddRoom(shared_ptr<Room> room) {
    rooms.push_back(room);
}

void ComponentFactory::RegisterComponent(const string& id, function<unique_ptr<Component>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Component> ComponentFactory::CreateComponent(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool ComponentFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void ComponentFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}



// ===== .\Dependence\map\component_base.h =====

﻿#pragma once

#include "room_base.h"
#include "building_base.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Building;
class Room;

class Component {
public:
    Component() = default;
    virtual ~Component() = default;

	// 子类实现方法

    // 动态返回组合静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

	// 父类实现方法

    // 关联建筑
    void SetParent(std::shared_ptr<Building> building);
    std::shared_ptr<Building> GetParent() const;

    // 获取/添加房间
    std::vector<std::shared_ptr<Room>>& GetRooms();
    void AddRoom(std::shared_ptr<Room> room);

protected:
    std::shared_ptr<Building> parentBuilding;

    std::vector<std::shared_ptr<Room>> rooms;
};

class ComponentFactory {
public:
    void RegisterComponent(const std::string& id, std::function<std::unique_ptr<Component>()> creator);
    std::unique_ptr<Component> CreateComponent(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Component>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\map\roadnet_base.cpp =====

﻿#include "roadnet_base.h"


using namespace std;

void RoadnetFactory::RegisterRoadnet(const string& id, function<unique_ptr<Roadnet>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Roadnet> RoadnetFactory::CreateRoadnet(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool RoadnetFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void RoadnetFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

unique_ptr<Roadnet> RoadnetFactory::GetRoadnet() const {
    for (auto config : configs) {
        if (config.second)return registries.find(config.first)->second();
    }
    return nullptr;
}


// ===== .\Dependence\map\roadnet_base.h =====

﻿#pragma once

#include "../common/plot.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Roadnet {
public:
    Roadnet() = default;
    virtual ~Roadnet() = default;

	// 子类实现方法

    // 动态返回路网名称
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 在平原上生成路网
    virtual void DistributeRoadnet(int width, int height,
        std::function<std::string(int, int)> get) = 0;

	// 父类实现方法

    // 提供只读访问接口
    const std::vector<Node>& GetNodes() const { return nodes; }
    const std::vector<Connection>& GetConnections() const { return connections; }
    const std::vector<std::shared_ptr<Plot>>& GetPlots() const { return plots; }

protected:
    std::vector<Node> nodes;
    std::vector<Connection> connections;
    std::vector<std::shared_ptr<Plot>> plots;
};

class RoadnetFactory {
public:
    void RegisterRoadnet(const std::string& id, std::function<std::unique_ptr<Roadnet>()> creator);
    std::unique_ptr<Roadnet> CreateRoadnet(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    std::unique_ptr<Roadnet> GetRoadnet() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Roadnet>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\map\room_base.cpp =====

﻿#include "room_base.h"


using namespace std;

void Room::SetParent(shared_ptr<Building> building) {
    parentBuilding = building;
}

void Room::SetParent(shared_ptr<Component> component) {
    parentComponent = component;
}

shared_ptr<Building> Room::GetParentBuilding() const {
    return parentBuilding;
}

shared_ptr<Component> Room::GetParentComponent() const {
    return parentComponent;
}

int Room::GetOwner() const {
    return ownerId;
}

void Room::SetOwner(int id) {
    this->ownerId = id;
}

bool Room::GetStateOwned() const {
    return stateOwned;
}

void Room::SetStateOwned(bool state) {
    this->stateOwned = state;
}

int Room::GetLayer() const {
    return layer;
}

void Room::SetLayer(int layer) {
    this->layer = layer;
}

int Room::GetFace() const {
    return face;
}

void Room::SetFace(int face) {
    this->face = face;
}

void RoomFactory::RegisterRoom(const string& id, function<unique_ptr<Room>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Room> RoomFactory::CreateRoom(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool RoomFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void RoomFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}



// ===== .\Dependence\map\room_base.h =====

﻿#pragma once

#include "../common/rect.h"

#include "component_base.h"
#include "building_base.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Building;
class Component;

class Room : public Rect {
public:
    Room() = default;
    virtual ~Room() = default;

	// 子类实现方法

    // 动态返回房间静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 房间类型
    virtual bool IsResidential() const = 0;
    virtual bool IsWorkspace() const = 0;
    virtual int GetLivingCapacity() const = 0;
    virtual int GetPersonnelCapacity() const = 0;

	// 父类实现方法

    // 关联建筑
    void SetParent(std::shared_ptr<Building> building);
    void SetParent(std::shared_ptr<Component> component);
    std::shared_ptr<Building> GetParentBuilding() const;
    std::shared_ptr<Component> GetParentComponent() const;

    // 获取/设置房东
    int GetOwner() const;
    void SetOwner(int id);
    bool GetStateOwned() const;
    void SetStateOwned(bool state);

    // 获取/设置属性
    int GetLayer() const;
    void SetLayer(int layer);
    int GetFace() const;
    void SetFace(int face);

protected:
    std::shared_ptr<Building> parentBuilding;
    std::shared_ptr<Component> parentComponent;

    bool stateOwned = false;
	int ownerId = -1;

    int layer;
    int face;
};

class RoomFactory {
public:
    void RegisterRoom(const std::string& id, std::function<std::unique_ptr<Room>()> creator);
    std::unique_ptr<Room> CreateRoom(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Room>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\map\terrain_base.cpp =====

﻿#include "terrain_base.h"


using namespace std;

void TerrainFactory::RegisterTerrain(const string& id, function<unique_ptr<Terrain>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Terrain> TerrainFactory::CreateTerrain(const string& id) const {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool TerrainFactory::CheckRegistered(const string& id) const {
    return registries.find(id) != registries.end();
}

void TerrainFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

vector<unique_ptr<Terrain>> TerrainFactory::GetTerrains() const {
    vector<unique_ptr<Terrain>> terrains;
    for (auto r : registries) {
        terrains.push_back(r.second());
    }
    return terrains;
}



// ===== .\Dependence\map\terrain_base.h =====

﻿#pragma once

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Terrain {
public:
    Terrain() = default;
    virtual ~Terrain() = default;

	// 子类实现方法

    // 动态返回地形静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 动态返回生成优先级
    virtual float GetPriority() const = 0;

    // 在地图上生成地形
    virtual void DistributeTerrain(int width, int height,
        std::function<bool(int, int, const std::string)> set, std::function<std::string(int, int)> get) const = 0;

	// 父类实现方法

protected:
};

class TerrainFactory {
public:
    void RegisterTerrain(const std::string& id, std::function<std::unique_ptr<Terrain>()> creator);
    std::unique_ptr<Terrain> CreateTerrain(const std::string& id) const;
    bool CheckRegistered(const std::string& id) const;
    void SetConfig(std::string name, bool config);
    std::vector<std::unique_ptr<Terrain>> GetTerrains() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Terrain>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\map\zone_base.cpp =====

﻿#include "zone_base.h"

#include "../common/error.h"

#include <algorithm>


using namespace std;

void Zone::SetParent(shared_ptr<Plot> plot) {
    parentPlot = plot;
}

shared_ptr<Plot> Zone::GetParent() const {
    return parentPlot;
}

int Zone::GetOwner() const {
    return ownerId;
}

void Zone::SetOwner(int id) {
    ownerId = id;
}

bool Zone::GetStateOwned() const {
    return stateOwned;
}

void Zone::SetStateOwned(bool state) {
    stateOwned = state;
}

shared_ptr<Building> Zone::GetBuilding(string name) {
    return buildings[name];
}

unordered_map<string, shared_ptr<Building>>& Zone::GetBuildings() {
    return buildings;
}

void Zone::AddBuildings(BuildingFactory* factory, vector<pair<string, float>> list) {
    float acreageTmp = 0.f;
    int attempt = 0;
    for (size_t i = 0; i < list.size(); i++) {
        if (acreageTmp >= GetAcreage() || attempt > 16)break;

        shared_ptr<Building> building = factory->CreateBuilding(list[i].first);
        if (!building) {
            attempt++;
            i--;
            continue;
        }

        float acreageBuilding = building->RandomAcreage() * list[i].second;
        float acreageMin = building->GetAcreageMin() * list[i].second;
        float acreageMax = building->GetAcreageMax() * list[i].second;
        if (GetAcreage() - acreageTmp < acreageMin) {
            attempt++;
            i--;
            continue;
        }
        else if (GetAcreage() - acreageTmp < acreageBuilding) {
            acreageBuilding = GetAcreage() - acreageTmp;
        }

        acreageTmp += acreageBuilding;
        building->SetAcreage(acreageBuilding);
        if(buildings.find(building->GetName()) != buildings.end()) {
            THROW_EXCEPTION(InvalidConfigException, "Duplicate building name: " + building->GetName() + ".\n");
		}
        buildings[building->GetName()] = building;
    }
}

void Zone::ArrangeBuildings() {
    if (buildings.empty()) return;

    float acreageTotal = GetAcreage();
    float acreageUsed = 0.f;

    for (const auto& building : buildings) {
        acreageUsed += building.second->GetAcreage();
    }
    float acreageRemain = acreageTotal - acreageUsed;

    bool acreageAllocate = false;
    if (acreageRemain > 0) {
        for (auto& building : buildings) {
            float acreageTmp = building.second->GetAcreage();
            float acreageMax = building.second->GetAcreageMax();
            float acreageMin = building.second->GetAcreageMin();

            float acreageExpand = acreageMax - acreageTmp;

            if (acreageExpand > acreageRemain && acreageRemain > 0) {
                float acreageNew = acreageTmp + acreageRemain;
                if (acreageNew >= acreageMin && acreageNew <= acreageMax) {
                    building.second->SetAcreage(acreageNew);
                    acreageUsed += acreageRemain;
                    acreageRemain = 0.f;
                    acreageAllocate = true;
                    break;
                }
            }
        }
    }

    vector<shared_ptr<Rect>> elements;
    if (acreageRemain > 0 && !acreageAllocate) {
        auto emptyRect = make_shared<Plot>();
        emptyRect->SetAcreage(acreageRemain);
        elements.push_back(emptyRect);
    }

    for (const auto& building : buildings) {
        elements.push_back(static_pointer_cast<Rect>(building.second));
    }

    if (elements.empty()) return;

    sort(elements.begin(), elements.end(), [](shared_ptr<Rect> a, shared_ptr<Rect> b) {
        return a->GetAcreage() > b->GetAcreage();
        });

    Rect container = Rect(GetSizeX() / 2, GetSizeY() / 2, GetSizeX(), GetSizeY());
    if (elements.size() == 1) {
        elements[0]->SetPosition(container.GetPosX(), container.GetPosY(), container.GetSizeX(), container.GetSizeY());
    }
    else {
        class Chunk : public Rect {
        public:
            Chunk(shared_ptr<Rect> r1, shared_ptr<Rect> r2) : r1(r1), r2(r2) { acreage = r1->GetAcreage() + r2->GetAcreage(); }
            shared_ptr<Rect> r1, r2;
        };
        while (elements.size() > 2) {
            shared_ptr<Chunk> tmp = make_shared<Chunk>(elements[elements.size() - 1], elements[elements.size() - 2]);
            elements.pop_back();
            int i = (int)elements.size() - 2;
            for (; i >= 0; i--) {
                if (tmp->GetAcreage() > elements[i]->GetAcreage()) {
                    elements[i + 1] = elements[i];
                }
                else {
                    elements[i + 1] = tmp;
                    break;
                }
            }
            if (i < 0)elements[0] = tmp;
        }

        if (container.GetSizeX() > container.GetSizeY()) {
            if (GetRandom(2)) {
                int divX = int(container.GetLeft() +
                    (container.GetRight() - container.GetLeft()) * elements[0]->GetAcreage() / container.GetAcreage());
                if (abs(divX - container.GetLeft()) < 2)divX = (int)container.GetLeft();
                if (abs(divX - container.GetRight()) < 2)divX = (int)container.GetRight();
                elements[0]->SetVertices(container.GetLeft(), container.GetBottom(), (float)divX, container.GetTop());
                elements[1]->SetVertices((float)divX, container.GetBottom(), container.GetRight(), container.GetTop());
            }
            else {
                int divX = int(container.GetLeft() +
                    (container.GetRight() - container.GetLeft()) * elements[1]->GetAcreage() / container.GetAcreage());
                if (abs(divX - container.GetLeft()) < 2)divX = (int)container.GetLeft();
                if (abs(divX - container.GetRight()) < 2)divX = (int)container.GetRight();
                elements[1]->SetVertices(container.GetLeft(), container.GetBottom(), (float)divX, container.GetTop());
                elements[0]->SetVertices((float)divX, container.GetBottom(), container.GetRight(), container.GetTop());
            }
        }
        else {
            if (GetRandom(2)) {
                int divY = int(container.GetBottom() +
                    (container.GetTop() - container.GetBottom()) * elements[0]->GetAcreage() / container.GetAcreage());
                if (abs(divY - container.GetBottom()) < 2)divY = (int)container.GetBottom();
                if (abs(divY - container.GetTop()) < 2)divY = (int)container.GetTop();
                elements[0]->SetVertices(container.GetLeft(), container.GetBottom(), container.GetRight(), (float)divY);
                elements[1]->SetVertices(container.GetLeft(), (float)divY, container.GetRight(), container.GetTop());
            }
            else {
                int divY = int(container.GetBottom() +
                    (container.GetTop() - container.GetBottom()) * elements[1]->GetAcreage() / container.GetAcreage());
                if (abs(divY - container.GetBottom()) < 2)divY = (int)container.GetBottom();
                if (abs(divY - container.GetTop()) < 2)divY = (int)container.GetTop();
                elements[1]->SetVertices(container.GetLeft(), container.GetBottom(), container.GetRight(), (float)divY);
                elements[0]->SetVertices(container.GetLeft(), (float)divY, container.GetRight(), container.GetTop());
            }
        }

        while (elements.size() > 0) {
            auto tmp = elements.back();
            elements.pop_back();
            if (auto chunk = dynamic_pointer_cast<Chunk>(tmp)) {
                shared_ptr<Rect> rect1 = chunk->r1;
                shared_ptr<Rect> rect2 = chunk->r2;

                if (tmp->GetAcreage() > 0) {
                    if (tmp->GetSizeX() > tmp->GetSizeY()) {
                        if (GetRandom(2)) {
                            int divX = int(tmp->GetLeft() +
                                tmp->GetSizeX() * rect1->GetAcreage() / tmp->GetAcreage());
                            if (abs(divX - tmp->GetLeft()) < 2)divX = (int)tmp->GetLeft();
                            if (abs(divX - tmp->GetRight()) < 2)divX = (int)tmp->GetRight();
                            rect1->SetVertices(tmp->GetLeft(), tmp->GetBottom(), (float)divX, tmp->GetTop());
                            rect2->SetVertices((float)divX, tmp->GetBottom(), tmp->GetRight(), tmp->GetTop());
                        }
                        else {
                            int divX = int(tmp->GetLeft() +
                                tmp->GetSizeX() * rect2->GetAcreage() / tmp->GetAcreage());
                            if (abs(divX - tmp->GetLeft()) < 2)divX = (int)tmp->GetLeft();
                            if (abs(divX - tmp->GetRight()) < 2)divX = (int)tmp->GetRight();
                            rect2->SetVertices(tmp->GetLeft(), tmp->GetBottom(), (float)divX, tmp->GetTop());
                            rect1->SetVertices((float)divX, tmp->GetBottom(), tmp->GetRight(), tmp->GetTop());
                        }
                    }
                    else {
                        if (GetRandom(2)) {
                            int divY = int(tmp->GetBottom() +
                                tmp->GetSizeY() * rect1->GetAcreage() / tmp->GetAcreage());
                            if (abs(divY - tmp->GetBottom()) < 2)divY = (int)tmp->GetBottom();
                            if (abs(divY - tmp->GetTop()) < 2)divY = (int)tmp->GetTop();
                            rect1->SetVertices(tmp->GetLeft(), tmp->GetBottom(), tmp->GetRight(), (float)divY);
                            rect2->SetVertices(tmp->GetLeft(), (float)divY, tmp->GetRight(), tmp->GetTop());
                        }
                        else {
                            int divY = int(tmp->GetBottom() +
                                tmp->GetSizeY() * rect2->GetAcreage() / tmp->GetAcreage());
                            if (abs(divY - tmp->GetBottom()) < 2)divY = (int)tmp->GetBottom();
                            if (abs(divY - tmp->GetTop()) < 2)divY = (int)tmp->GetTop();
                            rect2->SetVertices(tmp->GetLeft(), tmp->GetBottom(), tmp->GetRight(), (float)divY);
                            rect1->SetVertices(tmp->GetLeft(), (float)divY, tmp->GetRight(), tmp->GetTop());
                        }
                    }
                    if (dynamic_pointer_cast<Chunk>(rect1))elements.push_back(rect1);
                    if (dynamic_pointer_cast<Chunk>(rect2))elements.push_back(rect2);
                }
            }
        }
    }
}


void ZoneFactory::RegisterZone(const string& id,
    function<unique_ptr<Zone>()> creator,  GeneratorFunc generator) {
    registries[id] = creator;
    configs[id] = false;
    generators[id] = generator;
}

unique_ptr<Zone> ZoneFactory::CreateZone(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool ZoneFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void ZoneFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

void ZoneFactory::GenerateAll(const vector<shared_ptr<Plot>>& plots, BuildingFactory* factory) {
    for (const auto& [id, generator] : generators) {
        if (generator && configs[id]) {
            generator(this, factory, plots);
        }
    }
}



// ===== .\Dependence\map\zone_base.h =====

﻿#pragma once

#include "../common/rect.h"
#include "../common/plot.h"

#include "building_base.h"

#include <string>
#include <vector>
#include <functional>
#include <memory>
#include <unordered_map>


class Rect;
class Plot;
class Building;
class ZoneFactory;
class BuildingFactory;

class Zone : public Rect {
public:
    Zone() = default;
    virtual ~Zone() = default;

	// 子类实现方法

    // 动态返回园区静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 在地图中生成园区
    static std::function<void(ZoneFactory*, const std::vector<std::shared_ptr<Plot>>&)> ZoneGenerator;

	// 父类实现方法

    // 关联地块
    void SetParent(std::shared_ptr<Plot> plot);
    std::shared_ptr<Plot> GetParent() const;

    // 获取/设置房东
    int GetOwner() const;
    void SetOwner(int id);
	bool GetStateOwned() const;
	void SetStateOwned(bool state);

    // 获取/添加园区内建筑
    std::shared_ptr<Building> GetBuilding(std::string name);
    std::unordered_map<std::string, std::shared_ptr<Building>>& GetBuildings();
    void AddBuildings(BuildingFactory* factory, std::vector<std::pair<std::string, float>> list);

    // 自动分布建筑
    void ArrangeBuildings();

protected:
    std::shared_ptr<Plot> parentPlot;

	bool stateOwned = false;
    int ownerId = -1;

    std::unordered_map<std::string, std::shared_ptr<Building>> buildings;
};

class ZoneFactory {
public:
    using GeneratorFunc = std::function<void(
        ZoneFactory *, BuildingFactory*, const std::vector<std::shared_ptr<Plot>>&)>;

    void RegisterZone(const std::string& id,
        std::function<std::unique_ptr<Zone>()> creator, GeneratorFunc generator = nullptr);
    std::unique_ptr<Zone> CreateZone(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    void GenerateAll(const std::vector<std::shared_ptr<Plot>>& plots, BuildingFactory* factory);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Zone>()>> registries;
    std::unordered_map<std::string, bool> configs;
    std::unordered_map<std::string, GeneratorFunc> generators;
};


// ===== .\Dependence\populace\asset_base.cpp =====

﻿#include "asset_base.h"


using namespace std;

void AssetFactory::RegisterAsset(const string& id, function<unique_ptr<Asset>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Asset> AssetFactory::CreateAsset(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool AssetFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void AssetFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}


// ===== .\Dependence\populace\asset_base.h =====

﻿#pragma once

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Asset {
public:
    Asset() = default;
    virtual ~Asset() = default;

    // 子类实现方法

    // 动态返回姓名静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 父类实现方法

protected:
};

class AssetFactory {
public:
    void RegisterAsset(const std::string& id, std::function<std::unique_ptr<Asset>()> creator);
    std::unique_ptr<Asset> CreateAsset(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Asset>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\populace\job_base.cpp =====

﻿#include "job_base.h"


using namespace std;

void Job::SetCalendar(std::shared_ptr<Calendar>& calendar) {
    this->calendar = calendar;
}

std::shared_ptr<Calendar>& Job::GetCalendar() {
    return calendar;
}

void JobFactory::RegisterJob(const string& id, function<unique_ptr<Job>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Job> JobFactory::CreateJob(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool JobFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void JobFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}



// ===== .\Dependence\populace\job_base.h =====

﻿#pragma once

#include "../common/utility.h"
#include "../society/calendar_base.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Job {
public:
    Job() = default;
    virtual ~Job() = default;

	// 子类实现方法

    // 动态返回职业静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

	// 父类实现方法
    void SetCalendar(std::shared_ptr<Calendar> &calendar);
    std::shared_ptr<Calendar> &GetCalendar();

protected:
    std::shared_ptr<Calendar> calendar;

};

class JobFactory {
public:
    void RegisterJob(const std::string& id, std::function<std::unique_ptr<Job>()> creator);
    std::unique_ptr<Job> CreateJob(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Job>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\populace\name_base.cpp =====

﻿#include "name_base.h"
#include "job_base.h"


using namespace std;

void NameFactory::RegisterName(const string& id, function<unique_ptr<Name>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Name> NameFactory::CreateName(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool NameFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void NameFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

unique_ptr<Name> NameFactory::GetName() const {
    for (auto config : configs) {
        if (config.second)return registries.find(config.first)->second();
    }
    return nullptr;
}


// ===== .\Dependence\populace\name_base.h =====

﻿#pragma once

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Name {
public:
    Name() = default;
    virtual ~Name() = default;

    // 子类实现方法

    // 动态返回姓名静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 生成随机姓名
    virtual std::string GetSurname(std::string name) = 0;
    virtual std::string GenerateName(bool male = true, bool female = true, bool neutral = true) = 0;
    virtual std::string GenerateName(std::string surname, bool male = true, bool female = true, bool neutral = true) = 0;

    // 父类实现方法

protected:
};

class NameFactory {
public:
    void RegisterName(const std::string& id, std::function<std::unique_ptr<Name>()> creator);
    std::unique_ptr<Name> CreateName(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    std::unique_ptr<Name> GetName() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Name>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\populace\scheduler_base.cpp =====

﻿#include "scheduler_base.h"


using namespace std;

void SchedulerFactory::RegisterScheduler(const string& id, function<unique_ptr<Scheduler>()> creator, float power) {
    registries[id] = creator;
    configs[id] = false;
    powers[id] = power;
}

unique_ptr<Scheduler> SchedulerFactory::CreateScheduler(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool SchedulerFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void SchedulerFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

const unordered_map<string, float>& SchedulerFactory::GetPowers() const {
    return powers;
}


// ===== .\Dependence\populace\scheduler_base.h =====

﻿#pragma once

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Scheduler {
public:
    Scheduler() = default;
    virtual ~Scheduler() = default;

    // 子类实现方法

    // 动态返回姓名静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 组织权重
    static float GetPower();

    // 父类实现方法

protected:
};

class SchedulerFactory {
public:
    void RegisterScheduler(const std::string& id, std::function<std::unique_ptr<Scheduler>()> creator, float power);
    std::unique_ptr<Scheduler> CreateScheduler(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    const std::unordered_map<std::string, float>& GetPowers() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Scheduler>()>> registries;
    std::unordered_map<std::string, bool> configs;
    std::unordered_map<std::string, float> powers;
};

// ===== .\Dependence\script\change_base.cpp =====

﻿#include "change_base.h"


using namespace std;

void Change::SetCondition(Condition condition) {
    this->condition = condition;
}
Condition& Change::GetCondition() {
    return condition;
}

void ChangeFactory::RegisterChange(const string& id, function<unique_ptr<Change>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Change> ChangeFactory::CreateChange(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool ChangeFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void ChangeFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}




// ===== .\Dependence\script\change_base.h =====

﻿#pragma once

#include "../common/condition.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Change {
public:
    Change() = default;
    virtual ~Change() = default;

    // 子类实现方法

    // 动态返回组织静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 基变更列表
    virtual std::vector<std::shared_ptr<Change>> ApplyChange() = 0;

    // 父类实现方法

    // 设置/获取控制条件
    void SetCondition(Condition condition);
    Condition& GetCondition();

protected:
    Condition condition;
};

class ChangeFactory {
public:
    void RegisterChange(const std::string& id, std::function<std::unique_ptr<Change>()> creator);
    std::unique_ptr<Change> CreateChange(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Change>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\script\event_base.cpp =====

﻿#include "event_base.h"


using namespace std;

void Event::SetCondition(Condition condition) {
    this->condition = condition;
}

Condition& Event::GetCondition() {
    return condition;
}

void EventFactory::RegisterEvent(const string& id, function<unique_ptr<Event>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Event> EventFactory::CreateEvent(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool EventFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void EventFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}




// ===== .\Dependence\script\event_base.h =====

﻿#pragma once

#include "../common/condition.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>

#undef CreateEvent


class Event {
public:
    Event() = default;
    virtual ~Event() = default;

    // 子类实现方法

    // 动态返回组织静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 判断匹配
    virtual bool operator==(std::shared_ptr<Event> e) = 0;

    // 父类实现方法

    // 设置/获取控制条件
    void SetCondition(Condition condition);
    Condition& GetCondition();

protected:
    Condition condition;
};

class EventFactory {
public:
    void RegisterEvent(const std::string& id, std::function<std::unique_ptr<Event>()> creator);
    std::unique_ptr<Event> CreateEvent(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Event>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\society\calendar_base.cpp =====

﻿#include "calendar_base.h"


using namespace std;

void CalendarFactory::RegisterCalendar(const string& id, function<unique_ptr<Calendar>()> creator) {
    registries[id] = creator;
    configs[id] = false;
}

unique_ptr<Calendar> CalendarFactory::CreateCalendar(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool CalendarFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void CalendarFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}




// ===== .\Dependence\society\calendar_base.h =====

﻿#pragma once

#include "../common/utility.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>


class Calendar {
public:
    Calendar() = default;
    virtual ~Calendar() = default;

    // 子类实现方法

    // 动态返回组织静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    virtual std::pair<Time, Time> WorkingTime(Time date) const = 0;

    // 父类实现方法

protected:
};

class CalendarFactory {
public:
    void RegisterCalendar(const std::string& id, std::function<std::unique_ptr<Calendar>()> creator);
    std::unique_ptr<Calendar> CreateCalendar(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Calendar>()>> registries;
    std::unordered_map<std::string, bool> configs;
};

// ===== .\Dependence\society\organization_base.cpp =====

﻿#include "organization_base.h"


using namespace std;

vector<shared_ptr<Job>> Organization::EnrollEmployee(vector<int> ids) {
    vector<shared_ptr<Job>> positions;

    int i = 0;
    for (auto& component : jobs) {
        for (auto& vacancy : component.second) {
            if (vacancy.second < 0) {
                positions.push_back(vacancy.first);
                vacancy.second = ids[i++];
                if (i >= ids.size())return positions;
            }
        }
    }

    return positions;
}

vector<pair<shared_ptr<Component>, vector<pair<shared_ptr<Job>, int>>>> Organization::GetJobs() const {
    return jobs;
}

void Organization::AddVacancy(shared_ptr<Component> component, vector<shared_ptr<Job>> vacancies) {
    vector< pair<shared_ptr<Job>, int>> positions;
    for (auto vacancy : vacancies) {
        positions.push_back(make_pair(vacancy, -1));
    }
    jobs.push_back(make_pair(component, positions));
}

void OrganizationFactory::RegisterOrganization(const string& id, function<unique_ptr<Organization>()> creator, float power) {
    registries[id] = creator;
    configs[id] = false;
    powers[id] = power;
}

unique_ptr<Organization> OrganizationFactory::CreateOrganization(const string& id) {
    auto it = registries.find(id);
    if (it != registries.end()) {
        return it->second();
    }
    return nullptr;
}

bool OrganizationFactory::CheckRegistered(const string& id) {
    return registries.find(id) != registries.end();
}

void OrganizationFactory::SetConfig(string name, bool config) {
    if (configs.find(name) != configs.end()) {
        configs[name] = config;
    }
}

const unordered_map<string, float>& OrganizationFactory::GetPowers() const {
    return powers;
}




// ===== .\Dependence\society\organization_base.h =====

﻿#pragma once

#include "../map/component_base.h"
#include "../populace/job_base.h"
#include "../society/calendar_base.h"

#include <string>
#include <functional>
#include <memory>
#include <unordered_map>

#undef AddJob


class Organization {
public:
    Organization() = default;
    virtual ~Organization() = default;

	// 子类实现方法

    // 动态返回组织静态信息
    static std::string GetId();
    virtual std::string GetType() const = 0;
    virtual std::string GetName() const = 0;

    // 组织权重
    static float GetPower();

	// 所需组合及数量范围
	virtual std::vector<std::pair<std::string, std::pair<int, int>>> ComponentRequirements() const = 0;

	// 根据实际组合安排工作岗位
    virtual std::vector<std::pair<std::string, std::vector<std::string>>> ArrageVacancies(
        std::vector<std::pair<std::string, int>> components) const = 0;

    // 设定工作日历
    virtual void SetCalendar(CalendarFactory* factory) = 0;

    // 员工入职
    virtual std::vector<std::shared_ptr<Job>> EnrollEmployee(std::vector<int> ids);

	// 父类实现方法

	// 管理职位
    std::vector<std::pair<std::shared_ptr<Component>, std::vector<std::pair<std::shared_ptr<Job>, int>>>> GetJobs() const;
	void AddVacancy(std::shared_ptr<Component> component, std::vector<std::shared_ptr<Job>> vacancies);

protected:
	std::vector<std::pair<std::shared_ptr<Component>, std::vector<std::pair<std::shared_ptr<Job>, int>>>> jobs;
};

class OrganizationFactory {
public:
    void RegisterOrganization(const std::string& id, std::function<std::unique_ptr<Organization>()> creator, float power);
    std::unique_ptr<Organization> CreateOrganization(const std::string& id);
    bool CheckRegistered(const std::string& id);
    void SetConfig(std::string name, bool config);
    const std::unordered_map<std::string, float>& GetPowers() const;

private:
    std::unordered_map<std::string, std::function<std::unique_ptr<Organization>()>> registries;
    std::unordered_map<std::string, bool> configs;
    std::unordered_map<std::string, float> powers;
};

// ===== .\Forever\asset.cpp =====

﻿#include "asset.h"


using namespace std;

TestAsset::TestAsset() {

}

TestAsset::~TestAsset() {

}

ZoneAsset::ZoneAsset(shared_ptr<Zone> zone) : zone(zone) {

}

ZoneAsset::~ZoneAsset() {

}

shared_ptr<Zone> ZoneAsset::GetZone() {
	return zone;
}

void ZoneAsset::SetZone(shared_ptr<Zone> zone) {
	this->zone = zone;
}

BuildingAsset::BuildingAsset(shared_ptr<Building> building) : building(building) {

}

BuildingAsset::~BuildingAsset() {

}

shared_ptr<Building> BuildingAsset::GetBuilding() {
	return building;
}

void BuildingAsset::SetBuilding(shared_ptr<Building> building) {
	this->building = building;
}

RoomAsset::RoomAsset(shared_ptr<Room> room) : room(room) {

}

RoomAsset::~RoomAsset() {

}

shared_ptr<Room> RoomAsset::GetRoom() {
	return room;
}

void RoomAsset::SetRoom(shared_ptr<Room> room) {
	this->room = room;
}


// ===== .\Forever\asset.h =====

﻿#pragma once

#include "asset_base.h"
#include "zone_base.h"


// 子类注册函数
typedef void (*RegisterModAssetsFunc)(AssetFactory* factory);

// 主程序检测子类
class TestAsset : public Asset {
public:
    TestAsset();
    ~TestAsset();

    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试资产"; }

private:

};

// 园区资产子类
class ZoneAsset : public Asset {
public:
    ZoneAsset(std::shared_ptr<Zone> zone);
    ~ZoneAsset();

    static std::string GetId() { return "zoneAsset"; }
    virtual std::string GetType() const override { return "zoneAsset"; }
    virtual std::string GetName() const override { return "园区资产"; }

    std::shared_ptr<Zone> GetZone();
    void SetZone(std::shared_ptr<Zone> zone);

private:
    std::shared_ptr<Zone> zone;
};

// 建筑资产子类
class BuildingAsset : public Asset {
public:
    BuildingAsset(std::shared_ptr<Building> building);
    ~BuildingAsset();

    static std::string GetId() { return "buildingAsset"; }
    virtual std::string GetType() const override { return "buildingAsset"; }
    virtual std::string GetName() const override { return "建筑资产"; }

    std::shared_ptr<Building> GetBuilding();
    void SetBuilding(std::shared_ptr<Building> building);

private:
    std::shared_ptr<Building> building;
};

// 房间资产子类
class RoomAsset : public Asset {
public:
    RoomAsset(std::shared_ptr<Room> room);
    ~RoomAsset();

    static std::string GetId() { return "roomAsset"; }
    virtual std::string GetType() const override { return "roomAsset"; }
    virtual std::string GetName() const override { return "房间资产"; }

    std::shared_ptr<Room> GetRoom();
    void SetRoom(std::shared_ptr<Room> room);

private:
    std::shared_ptr<Room> room;
};


// ===== .\Forever\building.cpp =====

﻿#include "building.h"


using namespace std;

int TestBuilding::count = 0;


// ===== .\Forever\building.h =====

﻿#pragma once

#include "room.h"
#include "component.h"
#include "building_base.h"


// 子类注册函数
typedef void (*RegisterModBuildingsFunc)(BuildingFactory* factory);

// 主程序检测子类
class TestBuilding : public Building {
public:
    TestBuilding() {
        name = count++;
        layers = 2;
        basements = 1;
    }

    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return std::string("测试建筑") + std::to_string(name); }

    static std::vector<float> GetPower() { return std::vector<float>(13, 1.f); }

    virtual float RandomAcreage() const override { return 10000.f; }
    virtual float GetAcreageMin() const override { return 2000.f; }
    virtual float GetAcreageMax() const override { return 20000.f; }

    virtual void LayoutRooms(RoomFactory* factory, std::unique_ptr<Layout>& layout) override {
        int direction = GetRandom(4);

        auto component = CreateComponent<TestComponent>();
        ReadFloor(-1, GetSizeX() / 2.f, GetSizeY() / 2.f, direction, "single_room", layout);
        ReadFloor(0, GetSizeX() / 2.f, GetSizeY() / 2.f, direction, "straight_linear", layout);
        ReadFloor(1, GetSizeX() / 2.f, GetSizeY() / 2.f, direction, "straight_linear", layout);
        AssignRoom(-1, 0, "test", component, factory);
        ArrangeRow(0, 0, "test", 120.f, component, factory);
        ArrangeRow(0, 1, "test", 120.f, component, factory);
        ArrangeRow(1, 0, "test", 120.f, component, factory);
        ArrangeRow(1, 1, "test", 120.f, component, factory);
    }

private:
    static int count;

    int name;
};


// ===== .\Forever\calendar.cpp =====

﻿#include "calendar.h"


using namespace std;




// ===== .\Forever\calendar.h =====

﻿#pragma once

#include "calendar_base.h"

#include <string>
#include <vector>


// 子类注册函数
typedef void (*RegisterModCalendarsFunc)(CalendarFactory* factory);

// 主程序检测子类
class TestCalendar : public Calendar {
public:
	TestCalendar() {}
	virtual ~TestCalendar() {}

	static std::string GetId() { return "test"; }
	virtual std::string GetType() const override { return "test"; }
	virtual std::string GetName() const override { return "测试日程"; }

	virtual std::pair<Time, Time> WorkingTime(Time date) const override {
		int day = date.DayOfWeek();
		if (day >= 1 && day <= 5)return { Time("09:00:00.000"), Time("09:00:00.000") };
		else return { Time(), Time() };
	}
};


// ===== .\Forever\change.cpp =====

﻿#include "change.h"


using namespace std;

std::vector<std::shared_ptr<Change>> SetValueChange::ApplyChange() {
	return std::vector<std::shared_ptr<Change>>();
}

std::vector<std::shared_ptr<Change>> RemoveValueChange::ApplyChange() {
	return std::vector<std::shared_ptr<Change>>();
}


// ===== .\Forever\change.h =====

﻿#pragma once

#include "change_base.h"
#include "condition.h"

#include <string>
#include <vector>


// 子类注册函数
typedef void (*RegisterModChangesFunc)(ChangeFactory* factory);

class SetValueChange : public Change {
public:
	SetValueChange() {}
	SetValueChange(std::string variable, std::string value)
		: variable(variable), value(value) {
	}
	virtual ~SetValueChange() {}

	static std::string GetId() { return "set_value"; }
    virtual std::string GetType() const override { return "set_value"; }
	virtual std::string GetName() const override { return "set_value"; }

	virtual std::vector<std::shared_ptr<Change>> ApplyChange() override;

	void SetVariable(std::string variable) { this->variable = variable; }
	std::string GetVariable() { return variable; }
	void SetValue(std::string value) { this->value = value; }
	std::string GetValue() { return value; }

private:
	std::string variable;
	std::string value;
};

class RemoveValueChange : public Change {
public:
	RemoveValueChange() {}
	RemoveValueChange(std::string name)
		: variable(variable) {
	}
	virtual ~RemoveValueChange() {}

	static std::string GetId() { return "remove_value"; }
    virtual std::string GetType() const override { return "remove_value"; }
	virtual std::string GetName() const override { return "remove_value"; }

	void SetVariable(std::string variable) { this->variable = variable; }
	std::string GetVariable() { return variable; }

	virtual std::vector<std::shared_ptr<Change>> ApplyChange();

private:
	std::string variable;
};

// ===== .\Forever\component.cpp =====

﻿#include "component.h"


using namespace std;



// ===== .\Forever\component.h =====

﻿#pragma once

#include "component_base.h"


// 子类注册函数
typedef void (*RegisterModComponentsFunc)(ComponentFactory* factory);

// 主程序检测子类
class TestComponent : public Component {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试组合"; }
};


// ===== .\Forever\dialog.cpp =====

﻿#include "dialog.h"


using namespace std;

Dialog::Dialog() {

}

Dialog::~Dialog() {

}

void Dialog::AddDialog(string speaker, string content) {
	list.push_back(make_pair(speaker, content));
}

vector<pair<string, string>> Dialog::GetDialogs() {
	return list;
}

void Dialog::SetCondition(Condition condition) {
	this->condition = condition;
}
Condition& Dialog::GetCondition() {
	return condition;
}


// ===== .\Forever\dialog.h =====

#pragma once

#include "condition.h"

#include <vector>
#include <string>


class Dialog {
public:
	Dialog();
	~Dialog();

	// 添加/获取对话列表
	void AddDialog(std::string speaker, std::string content);
	std::vector<std::pair<std::string, std::string>> GetDialogs();

	// 设置/获取控制条件
	void SetCondition(Condition condition);
	Condition& GetCondition();

private:
	std::vector<std::pair<std::string, std::string>> list;

	Condition condition;
};

// ===== .\Forever\event.cpp =====

﻿#include "event.h"


using namespace std;




// ===== .\Forever\event.h =====

﻿#pragma once

#include "event_base.h"
#include "condition.h"

#include <string>
#include <vector>


// 子类注册函数
typedef void (*RegisterModEventsFunc)(EventFactory* factory);

class GameStartEvent : public Event {
public:
	GameStartEvent() {}
	virtual ~GameStartEvent() {}

	static std::string GetId() { return "game_start"; }
    virtual std::string GetType() const override { return "game_start"; }
	virtual std::string GetName() const override { return "game_start"; }

	virtual bool operator==(std::shared_ptr<Event> e) override {
		if (!e)return false;
		if (GetType() != e->GetType())return false;

		return true;
	}
};

class OptionDialogEvent : public Event {
public:
	OptionDialogEvent() {}
	OptionDialogEvent(std::string target, std::string option)
		: target(target), option(option) {
	}
	virtual ~OptionDialogEvent() {}

	static std::string GetId() { return "option_dialog"; }
    virtual std::string GetType() const override { return "option_dialog"; }
	virtual std::string GetName() const override { return "option_dialog"; }

	virtual bool operator==(std::shared_ptr<Event> e) {
		if(!e)return false;
		if (GetType() != e->GetType())return false;

		return target == std::dynamic_pointer_cast<OptionDialogEvent>(e)->target &&
			option == std::dynamic_pointer_cast<OptionDialogEvent>(e)->option;
	}

	void SetTarget(std::string target) { this->target = target; }
	std::string GetTarget() const { return target; }
	void SetOption(std::string option) { this->option = option; }
	std::string GetOption() const { return option; }

private:
	std::string target;
	std::string option;
};


// ===== .\Forever\experience.cpp =====

﻿#include "experience.h"


using namespace std;



// ===== .\Forever\experience.h =====

﻿#pragma once

#include "job.h"
#include "person.h"


class Person;

class Experience {
public:
    Experience() = default;
    virtual ~Experience() = default;

    // 获取/设置经历时间
    const Time& GetBeginTime() const { return begin; }
    const Time& GetEndTime() const { return end; }
    void SetTime(const Time& b, const Time& e) { begin = b; end = e; }

private:
    Time begin, end;
};

class EducationExperience : public Experience {
public:
    EducationExperience() = default;

    // 设置教育经历属性
    void SetSchool(const std::string& s) { school = s; }
    const std::string& GetSchool() const { return school; }
    void AddClassmate(std::shared_ptr<Person> p) { classmates.push_back(p); }
    void SetTeacher(std::shared_ptr<Person> t) { teacher = t; }
    const std::vector<std::shared_ptr<Person>>& GetClassmates() const { return classmates; }
    std::shared_ptr<Person> GetTeacher() const { return teacher; }
    void SetGraduate(bool g) { graduate = g; }
    bool GetGraduate() const { return graduate; }

private:
    std::string school;
    std::vector<std::shared_ptr<Person>> classmates;
    std::shared_ptr<Person> teacher = nullptr;

    bool graduate = true;
};

class EmotionExperience : public Experience {
public:
    EmotionExperience() = default;

    // 获取/设置情感经历属性
    std::shared_ptr<Person> GetPerson() const { return person; }
    void SetPerson(std::shared_ptr<Person> p) { person = p; }

private:
    std::shared_ptr<Person> person;
};


class JobExperience : public Experience {
public:
    JobExperience() = default;

    // 获取/设置工作经历属性
    void SetOrganization(std::string organization) { this->organization = organization; }
    std::string GetOrganization() const { return organization; }
    void AddColleague(std::shared_ptr<Person> p) { colleagues.push_back(p); }
    const std::vector<std::shared_ptr<Person>>& GetColleagues() const { return colleagues; }

private:
    std::string organization;
    std::vector<std::shared_ptr<Person>> colleagues;
};


// ===== .\Forever\job.cpp =====

﻿#include "job.h"


using namespace std;



// ===== .\Forever\job.h =====

﻿#pragma once

#include "job_base.h"


// 子类注册函数
typedef void (*RegisterModJobsFunc)(JobFactory* factory);

// 主程序检测子类
class TestJob : public Job {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试职业"; }
};


// ===== .\Forever\map.cpp =====

﻿#include "utility.h"
#include "error.h"
#include "map.h"
#include "json.h"

#include <algorithm>
#include <fstream>
#include <filesystem>


using namespace std;

string Element::GetTerrain() const {
    return terrain;
}

bool Element::SetTerrain(string terrain) {
    this->terrain = terrain;

    return true;
}

string Element::GetZone() const {
    return this->zone;
}

bool Element::SetZone(string zone) {
    this->zone = zone;

    return true;
}

string Element::GetBuilding() const {
    return this->building;
}

bool Element::SetBuilding(string building) {
    this->building = building;

    return true;
}

Block::Block(int x, int y) : offsetX(x), offsetY(y) {
    elements = vector<vector<shared_ptr<Element>>>(BLOCK_SIZE,
        vector<shared_ptr<Element>>(BLOCK_SIZE, nullptr));

    for (int i = 0; i < BLOCK_SIZE; i++) {
        for (int j = 0; j < BLOCK_SIZE; j++) {
            elements[j][i] = make_shared<Element>();
        }
    }
}

Block::~Block() {

}

string Block::GetTerrain(int x, int y) const {
    if (!CheckXY(x, y))
        return "";

    return elements[y - offsetY][x - offsetX]->GetTerrain();
}

bool Block::SetTerrain(int x, int y, string terrain) {
    if (!CheckXY(x, y)) {
        return false;
    }

    return elements[y - offsetY][x - offsetX]->SetTerrain(terrain);
}

bool Block::CheckXY(int x, int y) const {
    if (x < offsetX)return false;
    if (y < offsetY)return false;
    if (x >= offsetX + BLOCK_SIZE)return false;
    if (y >= offsetY + BLOCK_SIZE)return false;
    return true;
}

shared_ptr<Element> Block::GetElement(int x, int y) {
    if (CheckXY(x, y))
        return elements[y - offsetY][x - offsetX];
    else
        return nullptr;
}

Map::Map() {
    terrainFactory.reset(new TerrainFactory());
    roadnetFactory.reset(new RoadnetFactory());
    zoneFactory.reset(new ZoneFactory());
    buildingFactory.reset(new BuildingFactory());
    componentFactory.reset(new ComponentFactory());
    roomFactory.reset(new RoomFactory());
}

Map::~Map() {
    for (auto& mod : modHandles) {
        if (mod) {
            //FreeLibrary(mod);
        }
    }
    modHandles.clear();
}

void Map::InitTerrains() {
    terrainFactory->RegisterTerrain(TestTerrain::GetId(),
        []() { return make_unique<TestTerrain>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModTerrainsFunc registerFunc = (RegisterModTerrainsFunc)GetProcAddress(modHandle, "RegisterModTerrains");
        if (registerFunc) {
            registerFunc(terrainFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto terrainList = { "test", "mod" };
    for (const auto& terrainId : terrainList) {
        if (terrainFactory->CheckRegistered(terrainId)) {
            auto terrain = terrainFactory->CreateTerrain(terrainId);
            debugf(("Created terrain: " + terrain->GetName() + " (ID: " + terrainId + ").\n").data());
        }
        else {
            debugf("Terrain not registered: %s.\n", terrainId);
        }
    }
#endif // MOD_TEST

}

void Map::InitRoadnets() {
    roadnetFactory->RegisterRoadnet(TestRoadnet::GetId(), []() { return make_unique<TestRoadnet>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModRoadnetsFunc registerFunc = (RegisterModRoadnetsFunc)GetProcAddress(modHandle, "RegisterModRoadnets");
        if (registerFunc) {
            registerFunc(roadnetFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto roadnetList = { "test", "mod" };
    for (const auto& roadnetId : roadnetList) {
        if (roadnetFactory->CheckRegistered(roadnetId)) {
            auto roadnet = roadnetFactory->CreateRoadnet(roadnetId);
            debugf(("Created roadnet: " + roadnet->GetName() + " (ID: " + roadnetId + ").\n").data());
        }
        else {
            debugf("Roadnet not registered: %s.\n", roadnetId);
        }
    }
#endif // MOD_TEST

}

void Map::InitZones() {
    zoneFactory->RegisterZone(TestZone::GetId(),
        []() { return make_unique<TestZone>(); }, TestZone::ZoneGenerator);

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModZonesFunc registerFunc = (RegisterModZonesFunc)GetProcAddress(modHandle, "RegisterModZones");
        if (registerFunc) {
            registerFunc(zoneFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto zoneList = { "test", "mod" };
    for (const auto& zoneId : zoneList) {
        if (zoneFactory->CheckRegistered(zoneId)) {
            auto zone = zoneFactory->CreateZone(zoneId);
            debugf(("Created zone: " + zone->GetName() + " (ID: " + zoneId + ").\n").data());
        }
        else {
            debugf("Zone not registered: %s.\n", zoneId);
        }
    }
#endif // MOD_TEST

}

void Map::InitBuildings() {
    buildingFactory->RegisterBuilding(TestBuilding::GetId(),
        []() { return make_unique<TestBuilding>(); }, TestBuilding::GetPower());

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModBuildingsFunc registerFunc = (RegisterModBuildingsFunc)GetProcAddress(modHandle, "RegisterModBuildings");
        if (registerFunc) {
            registerFunc(buildingFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto buildingList = { "test", "mod" };
    for (const auto& buildingId : buildingList) {
        if (buildingFactory->CheckRegistered(buildingId)) {
            auto building = buildingFactory->CreateBuilding(buildingId);
            debugf(("Created building: " + building->GetName() + " (ID: " + buildingId + ").\n").data());
        }
        else {
            debugf("Building not registered: %s.\n", buildingId);
        }
    }
#endif // MOD_TEST

}

void Map::InitComponents() {
    componentFactory->RegisterComponent(TestComponent::GetId(), []() { return make_unique<TestComponent>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModComponentsFunc registerFunc = (RegisterModComponentsFunc)GetProcAddress(modHandle, "RegisterModComponents");
        if (registerFunc) {
            registerFunc(componentFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto componentList = { "test", "mod" };
    for (const auto& componentId : componentList) {
        if (componentFactory->CheckRegistered(componentId)) {
            auto component = componentFactory->CreateComponent(componentId);
            debugf(("Created component: " + component->GetName() + " (ID: " + componentId + ").\n").data());
        }
        else {
            debugf("Component not registered: %s.\n", componentId);
        }
    }
#endif // MOD_TEST

}

void Map::InitRooms() {
    roomFactory->RegisterRoom(TestRoom::GetId(), []() { return make_unique<TestRoom>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModRoomsFunc registerFunc = (RegisterModRoomsFunc)GetProcAddress(modHandle, "RegisterModRooms");
        if (registerFunc) {
            registerFunc(roomFactory.get());
        }
        else {
            debugf("Incorrect dll content.\n");
        }
    }
    else {
        debugf("Failed to load mod.dll.\n");
    }

#ifdef MOD_TEST
    auto roomList = { "test", "mod" };
    for (const auto& roomId : roomList) {
        if (roomFactory->CheckRegistered(roomId)) {
            auto room = roomFactory->CreateRoom(roomId);
            debugf(("Created room: " + room->GetName() + " (ID: " + roomId + ").\n").data());
        }
        else {
            debugf("Room not registered: %s.\n", roomId);
        }
    }
#endif // MOD_TEST

}

void Map::ReadConfigs(string path) const {
    if (!filesystem::exists(path)) {
        THROW_EXCEPTION(IOException, "Path does not exist: " + path + ".\n");
    }

    Json::Reader reader;
    Json::Value root;

    ifstream fin(path);
    if (!fin.is_open()) {
        THROW_EXCEPTION(IOException, "Failed to open file: " + path + ".\n");
    }
    if (reader.parse(fin, root)) {
        for (auto terrain : root["mods"]["terrain"]) {
            terrainFactory->SetConfig(terrain.asString(), true);
        }
        roadnetFactory->SetConfig(root["mods"]["roadnet"].asString(), true);
        for (auto zone : root["mods"]["zone"]) {
            zoneFactory->SetConfig(zone.asString(), true);
        }
        for (auto building : root["mods"]["building"]) {
            buildingFactory->SetConfig(building.asString(), true);
        }
        for (auto component : root["mods"]["component"]) {
            componentFactory->SetConfig(component.asString(), true);
        }
        for (auto room : root["mods"]["room"]) {
            roomFactory->SetConfig(room.asString(), true);
        }

    }
    else {
        fin.close();
        THROW_EXCEPTION(JsonFormatException, "Json syntax error: " + reader.getFormattedErrorMessages() + ".\n");
    }
    fin.close();
}

int Map::Init(int blockX, int blockY) {
    // 清除已有内容
    Destroy();

    // 地图尺寸需要为正
    if (blockX < 1 || blockY < 1) {
        THROW_EXCEPTION(InvalidArgumentException, "Invalid map size.\n");
        return 0;
    }

    // 计算地图实际长宽
    width = blockX * BLOCK_SIZE;
    height = blockY * BLOCK_SIZE;

    // 构建区块
    blocks = vector<vector<shared_ptr<Block>>>(blockY,
        vector<shared_ptr<Block>>(blockX, nullptr));
    for (int i = 0; i < blockX; i++) {
        for (int j = 0; j < blockY; j++) {
            blocks[j][i] = make_shared<Block>(i * BLOCK_SIZE, j * BLOCK_SIZE);
        }
    }

    // 生成地形
    auto getTerrain = [this](int x, int y) -> string {
        return this->GetTerrain(x, y);
        };
    auto setTerrain = [this](int x, int y, const string terrain) -> bool {
        return this->SetTerrain(x, y, terrain);
        };
    auto terrains = terrainFactory->GetTerrains();
    sort(terrains.begin(), terrains.end(),
        [](const unique_ptr<Terrain>& a, const unique_ptr<Terrain>& b) {
            return a->GetPriority() < b->GetPriority();
        });
    for (auto& terrain : terrains) {
        terrain->DistributeTerrain(width, height, setTerrain, getTerrain);
    }

    // 随机生成路网
    roadnet = roadnetFactory->GetRoadnet();
    if (!roadnet) {
        THROW_EXCEPTION(InvalidConfigException, "No enabled roadnet in config.\n");
    }
    roadnet->DistributeRoadnet(width, height, getTerrain);

    // 随机生成园区
    zoneFactory->GenerateAll(roadnet->GetPlots(), buildingFactory.get());
    for (auto plot : roadnet->GetPlots()) {
        auto zs = plot->GetZones();
        for (auto z : zs) {
            z.second->SetParent(plot);
            for (auto b : z.second->GetBuildings()) {
                b.second->SetParent(z.second);
                b.second->SetParent(plot);
            }
            if(zones.find(z.first) != zones.end()) {
                THROW_EXCEPTION(InvalidConfigException, "Duplicate zone name: " + z.first + ".\n");
            }
            zones[z.first] = z.second;
        }
    }

    // 随机生成建筑
    auto powers = buildingFactory->GetPowers();
    vector<vector<pair<string, float>>> cdfs(AREA_OFFICIAL_LOW + 1);
    for (int area = 0; area <= AREA_OFFICIAL_LOW; area++) {
        float sum = 0.f;
        for (auto power : powers) {
            sum += power.second[area];
            cdfs[area].emplace_back(power.first, sum);
        }
        if (sum == 0.f) {
            THROW_EXCEPTION(InvalidArgumentException, "No valid building for generation.\n");
        }
        for (auto& cdf : cdfs[area]) {
            cdf.second /= sum;
        }
    }
    for (auto plot : roadnet->GetPlots()) {
        float acreagePlot = plot->GetAcreage();
        for (auto zone : plot->GetZones()) {
            acreagePlot -= zone.second->GetAcreage();
        }
        if (acreagePlot <= 0.f)continue;

        float acreageTmp = 0.f;
        int attempt = 0;
        while (acreageTmp < acreagePlot) {
            if (attempt > 16)break;

            shared_ptr<Building> building;

            float rand = GetRandom(int(1e5)) / 1e5f;
            for (auto cdf : cdfs[plot->GetArea()]) {
                if (rand < cdf.second) {
                    building = buildingFactory->CreateBuilding(cdf.first);
                    break;
                }
            }

            if (!building) {
                attempt++;
                continue;
            }

            float acreageBuilding = building->RandomAcreage();
            float acreageMin = building->GetAcreageMin();
            float acreageMax = building->GetAcreageMax();
            if (acreagePlot - acreageTmp < acreageMin) {
                attempt++;
                continue;
            }
            else if (acreagePlot - acreageTmp < acreageBuilding) {
                acreageBuilding = acreagePlot - acreageTmp;
            }

            acreageTmp += acreageBuilding;
            building->SetAcreage(acreageBuilding);
            building->SetParent(plot);
            plot->AddBuilding(building->GetName(), building);
            if(buildings.find(building->GetName()) != buildings.end()) {
                THROW_EXCEPTION(InvalidConfigException, "Duplicate building name: " + building->GetName() + ".\n");
			}
			buildings[building->GetName()] = building;
        }
    }

    // 随机分布建筑与园区
    ArrangePlots();
    for (auto plot : roadnet->GetPlots()) {
        auto zones = plot->GetZones();
        for (auto zone : zones) {
            zone.second->ArrangeBuildings();
            SetZone(zone.second, zone.first);
            for (auto building : zone.second->GetBuildings()) {
                SetBuilding(building.second, building.first, make_pair(zone.second->GetLeft(), zone.second->GetBottom()));
            }
        }
        auto buildings = plot->GetBuildings();
        for (auto building : buildings) {
            SetBuilding(building.second, building.first);
        }
    }

    // 随机生成组合与房间
    layout = Building::ReadTemplates(REPLACE_PATH("../Resources/layouts/"));
    for (auto &building : buildings) {
        building.second->FinishInit();
        building.second->LayoutRooms(roomFactory.get(), layout);
        for (auto component : building.second->GetComponents()) {
            component->SetParent(building.second);
            for (auto room : component->GetRooms()) {
                room->SetParent(component);
                room->SetParent(building.second);
            }
        }
    }
    for (auto zone : zones) {
        for (auto& building : zone.second->GetBuildings()) {
            building.second->FinishInit();
            building.second->LayoutRooms(roomFactory.get(), layout);
            for (auto component : building.second->GetComponents()) {
                component->SetParent(building.second);
                for (auto room : component->GetRooms()) {
                    room->SetParent(component);
                    room->SetParent(building.second);
                }
            }
        }
    }

    return 20000;
}

void Map::Checkin(std::vector<std::shared_ptr<Person>> citizens, Time time) {
	// 筛选成年市民
	auto adults = vector<shared_ptr<Person>>();
    for (auto citizen : citizens) {
		if (citizen->GetAge(time) < 18)continue;
		adults.push_back(citizen);
    }
	if (adults.size() == 0)return;

    // 为房产分配房东
	auto residences = vector<pair<shared_ptr<Room>, int>>();
    for(auto zone : zones) {
        // 政府园区
        if (zone.second->GetStateOwned()) {
            for (auto building : zone.second->GetBuildings()) {
				building.second->SetStateOwned(true);
                for (auto room : building.second->GetRooms()) {
					room->SetStateOwned(true);
                    if(room->IsResidential()) {
                        residences.push_back({ room, 0 });
					}
                }
            }
            continue;
        }

        // 私人单人园区
        if(GetRandom(100) < 2) {
            int index = GetRandom(int(adults.size()));
			zone.second->SetOwner(index);
            citizens[index]->AddAsset(make_shared<ZoneAsset>(zone.second));
            for (auto building : zone.second->GetBuildings()) {
				building.second->SetOwner(index);
                for (auto room : building.second->GetRooms()) {
                    room->SetOwner(index);
                    if (room->IsResidential()) {
                        residences.push_back({ room, 0 });
                    }
                }
            }
        }
        // 私人混合园区
        else {
            for(auto building : zone.second->GetBuildings()) {
                // 私人单人建筑
                if (GetRandom(100) < 5) {
                    int index = GetRandom(int(adults.size()));
                    building.second->SetOwner(index);
                    citizens[index]->AddAsset(make_shared<BuildingAsset>(building.second));
                    for (auto room : building.second->GetRooms()) {
                        room->SetOwner(index);
                        if (room->IsResidential()) {
                            residences.push_back({ room, 0 });
                        }
                    }
                }
				// 私人混合建筑
                else {
                    for(auto room : building.second->GetRooms()) {
                        int index = GetRandom(int(adults.size()));
                        room->SetOwner(index);
                        citizens[index]->AddAsset(make_shared<RoomAsset>(room));
                        if (room->IsResidential()) {
                            residences.push_back({ room, 0 });
                        }
					}
                }
			}
        }
	}
    for(auto building : buildings) {
		// 政府建筑
        if (building.second->GetStateOwned()) {
            for (auto room : building.second->GetRooms()) {
                room->SetStateOwned(true);
                if (room->IsResidential()) {
                    residences.push_back({ room, 0 });
                }
            }
            continue;
        }

        // 私人单人建筑
        if (GetRandom(100) < 5) {
            int index = GetRandom(int(adults.size()));
            building.second->SetOwner(index);
            citizens[index]->AddAsset(make_shared<BuildingAsset>(building.second));
            for(auto room : building.second->GetRooms()) {
                room->SetOwner(index);
                if (room->IsResidential()) {
                    residences.push_back({ room, 0 });
                }
			}
		}
		// 私人混合建筑
        else {
            for (auto room : building.second->GetRooms()) {
                int index = GetRandom(int(adults.size()));
                room->SetOwner(index);
                citizens[index]->AddAsset(make_shared<RoomAsset>(room));
                if (room->IsResidential()) {
                    residences.push_back({ room, 0 });
                }
            }
        }
	}

	// 分配市民住所
    for (auto adult : adults) {
        if (adult->GetHome())continue;
        if (residences.size() <= 0)break;

		int index = GetRandom((int)residences.size());
        auto& residence = residences[index];

        int num = 1;
        adult->SetHome(residence.first);
        if (adult->GetSpouse() && adult->GetSpouse()->GetHome() == nullptr) {
            if (GetRandom(10) > 0) {
                adult->GetSpouse()->SetHome(residence.first);
                num++;
                for (auto child : adult->GetChilds()) {
                    if (child->GetAge(time) < 18) {
                        child->SetHome(residence.first);
                        num++;
                    }
                }
            }
        }

        if (num >= residence.second) {
            residences[index] = residences.back();
            residences.pop_back();
        }
    }
}

void Map::Destroy() {
    blocks.clear();
}

void Map::Tick() {

}

void Map::Print() {

}

void Map::ApplyChange(shared_ptr<Change> change, std::unique_ptr<Script>& script) {

}

void Map::Load(string path) {

}

void Map::Save(string path) {

}

pair<int, int> Map::GetSize() {
    return make_pair(width, height);
}

bool Map::CheckXY(int x, int y) const {
    if (x < 0)return false;
    if (y < 0)return false;
    if (x >= width)return false;
    if (y >= height)return false;
    return true;
}

shared_ptr<Block> Map::GetBlock(int x, int y) const {
    if (!CheckXY(x, y)) {
        throw invalid_argument("invalid block query position.\n");
        return nullptr;
    }

    int blockX = x / BLOCK_SIZE;
    int blockY = y / BLOCK_SIZE;

    return blocks[blockY][blockX];
}

shared_ptr<Element> Map::GetElement(int x, int y) const {
    if (!CheckXY(x, y)) {
        throw invalid_argument("invalid block query position.\n");
        return nullptr;
    }

    int blockX = x / BLOCK_SIZE;
    int blockY = y / BLOCK_SIZE;

    return blocks[blockY][blockX]->GetElement(x, y);
}

shared_ptr<Roadnet> Map::GetRoadnet() const {
    return roadnet;
}

std::vector<std::shared_ptr<Component>> Map::GetComponents() const {
    std::vector<std::shared_ptr<Component>> components;
    for(const auto & zone : zones) {
        for(auto building : zone.second->GetBuildings()) {
            const auto& current = building.second->GetComponents();
            components.insert(components.end(), current.begin(), current.end());
		}
	}
    for (const auto& building : buildings) {
        const auto& current = building.second->GetComponents();
        components.insert(components.end(), current.begin(), current.end());
    }
	return components;
}

shared_ptr<Zone> Map::GetZone(string name) {
	return zones[name];
}

shared_ptr<Building> Map::GetBuilding(string name) {
	return buildings[name];
}

void Map::SetZone(shared_ptr<Zone> zone, string name) {
    auto plot = zone->GetParent();

    auto v1 = plot->GetPosition(zone->GetPosX() + zone->GetSizeX() / 2.f, zone->GetPosY() + zone->GetSizeY() / 2.f);
    auto v2 = plot->GetPosition(zone->GetPosX() - zone->GetSizeX() / 2.f, zone->GetPosY() + zone->GetSizeY() / 2.f);
    auto v3 = plot->GetPosition(zone->GetPosX() - zone->GetSizeX() / 2.f, zone->GetPosY() - zone->GetSizeY() / 2.f);
    auto v4 = plot->GetPosition(zone->GetPosX() + zone->GetSizeX() / 2.f, zone->GetPosY() - zone->GetSizeY() / 2.f);

    vector<pair<float, float>> points = { v1, v2, v3, v4 };
    int minX = (int)points[0].first;
    int maxX = (int)points[0].first;
    int minY = (int)points[0].second;
    int maxY = (int)points[0].second;
    for (const auto& point : points) {
        minX = min(minX, (int)point.first);
        maxX = max(maxX, (int)point.first);
        minY = min(minY, (int)point.second);
        maxY = max(maxY, (int)point.second);
    }

    for (int x = minX; x <= maxX; x++) {
        for (int y = minY; y <= maxY; y++) {
            bool inside = false;
            for (size_t i = 0, j = points.size() - 1; i < points.size(); j = i++) {
                if (((points[i].second > y) != (points[j].second > y)) &&
                    (x < (points[j].first - points[i].first) * (y - points[i].second) /
                        (points[j].second - points[i].second) + points[i].first)) {
                    inside = !inside;
                }
            }

            if (inside) {
                auto element = GetElement((int)x, (int)y);
                if(element)element->SetZone(name);
            }
        }
    }
}

void Map::SetBuilding(shared_ptr<Building> building, string name) {
    auto plot = building->GetParentPlot();

    auto v1 = plot->GetPosition(building->GetPosX() + building->GetSizeX() / 2.f, building->GetPosY() + building->GetSizeY() / 2.f);
    auto v2 = plot->GetPosition(building->GetPosX() - building->GetSizeX() / 2.f, building->GetPosY() + building->GetSizeY() / 2.f);
    auto v3 = plot->GetPosition(building->GetPosX() - building->GetSizeX() / 2.f, building->GetPosY() - building->GetSizeY() / 2.f);
    auto v4 = plot->GetPosition(building->GetPosX() + building->GetSizeX() / 2.f, building->GetPosY() - building->GetSizeY() / 2.f);

    vector<pair<float, float>> points = { v1, v2, v3, v4 };
    int minX = (int)points[0].first;
    int maxX = (int)points[0].first;
    int minY = (int)points[0].second;
    int maxY = (int)points[0].second;
    for (const auto& point : points) {
        minX = min(minX, (int)point.first);
        maxX = max(maxX, (int)point.first);
        minY = min(minY, (int)point.second);
        maxY = max(maxY, (int)point.second);
    }

    for (int x = minX; x <= maxX; x++) {
        for (int y = minY; y <= maxY; y++) {
            bool inside = false;
            for (size_t i = 0, j = points.size() - 1; i < points.size(); j = i++) {
                if (((points[i].second > y) != (points[j].second > y)) &&
                    (x < (points[j].first - points[i].first) * (y - points[i].second) /
                        (points[j].second - points[i].second) + points[i].first)) {
                    inside = !inside;
                }
            }

            if (inside) {
                auto element = GetElement((int)x, (int)y);
                if (element)element->SetBuilding(name);
            }
        }
    }
}

void Map::SetBuilding(shared_ptr<Building> building, string name, pair<float, float> offset) {
    auto plot = building->GetParentPlot();

    auto v1 = plot->GetPosition(offset.first + building->GetPosX() + building->GetSizeX() / 2.f, offset.second + building->GetPosY() + building->GetSizeY() / 2.f);
    auto v2 = plot->GetPosition(offset.first + building->GetPosX() - building->GetSizeX() / 2.f, offset.second + building->GetPosY() + building->GetSizeY() / 2.f);
    auto v3 = plot->GetPosition(offset.first + building->GetPosX() - building->GetSizeX() / 2.f, offset.second + building->GetPosY() - building->GetSizeY() / 2.f);
    auto v4 = plot->GetPosition(offset.first + building->GetPosX() + building->GetSizeX() / 2.f, offset.second + building->GetPosY() - building->GetSizeY() / 2.f);

    vector<pair<float, float>> points = { v1, v2, v3, v4 };
    int minX = (int)points[0].first;
    int maxX = (int)points[0].first;
    int minY = (int)points[0].second;
    int maxY = (int)points[0].second;
    for (const auto& point : points) {
        minX = min(minX, (int)point.first);
        maxX = max(maxX, (int)point.first);
        minY = min(minY, (int)point.second);
        maxY = max(maxY, (int)point.second);
    }

    for (int x = minX; x <= maxX; x++) {
        for (int y = minY; y <= maxY; y++) {
            bool inside = false;
            for (size_t i = 0, j = points.size() - 1; i < points.size(); j = i++) {
                if (((points[i].second > y) != (points[j].second > y)) &&
                    (x < (points[j].first - points[i].first) * (y - points[i].second) /
                        (points[j].second - points[i].second) + points[i].first)) {
                    inside = !inside;
                }
            }

            if (inside) {
                auto element = GetElement((int)x, (int)y);
                if (element)element->SetBuilding(name);
            }
        }
    }
}

string Map::GetTerrain(int x, int y) const {
    if (!CheckXY(x, y)) {
        return "";
    }

    int blockX = x / BLOCK_SIZE;
    int blockY = y / BLOCK_SIZE;

    if (blockY >= blocks.size() || blockX >= blocks[0].size()) {
        return "";
    }

    return blocks[blockY][blockX]->GetTerrain(x, y);
}

bool Map::SetTerrain(int x, int y, string terrain) {
    if (!CheckXY(x, y)) {
        return false;
    }

    int blockX = x / BLOCK_SIZE;
    int blockY = y / BLOCK_SIZE;

    if (blockY >= blocks.size() || blockX >= blocks[0].size()) {
        return false;
    }

    return blocks[blockY][blockX]->SetTerrain(x, y, terrain);
}

void Map::ArrangePlots() {
    auto plots = roadnet->GetPlots();
    for (auto plot : plots) {
        auto zones = plot->GetZones();
        auto buildings = plot->GetBuildings();

        if (zones.empty() && buildings.empty()) continue;

        float acreageTotal = plot->GetAcreage();
        float acreageUsed = 0.f;

        for (const auto& zone : zones) {
            acreageUsed += zone.second->GetAcreage();
        }
        for (const auto& building : buildings) {
            acreageUsed += building.second->GetAcreage();
        }
        float acreageRemain = acreageTotal - acreageUsed;

        bool acreageAllocate = false;
        if (acreageRemain > 0) {
            for (auto& building : buildings) {
                float acreageTmp = building.second->GetAcreage();
                float acreageMax = building.second->GetAcreageMax();
                float acreageMin = building.second->GetAcreageMin();

                float acreageExpand = acreageMax - acreageTmp;

                if (acreageExpand > acreageRemain && acreageRemain > 0) {
                    float acreageNew = acreageTmp + acreageRemain;
                    if (acreageNew >= acreageMin && acreageNew <= acreageMax) {
                        building.second->SetAcreage(acreageNew);
                        acreageUsed += acreageRemain;
                        acreageRemain = 0.f;
                        acreageAllocate = true;
                        break;
                    }
                }
            }
        }

        vector<shared_ptr<Rect>> elements;
        if (acreageRemain > 0 && !acreageAllocate) {
            auto emptyRect = make_shared<Plot>();
            emptyRect->SetAcreage(acreageRemain);
            elements.push_back(emptyRect);
        }

        for (const auto& zone : zones) {
            elements.push_back(static_pointer_cast<Rect>(zone.second));
        }
        for (const auto& building : buildings) {
            elements.push_back(static_pointer_cast<Rect>(building.second));
        }

        if (elements.empty()) continue;

        sort(elements.begin(), elements.end(), [](shared_ptr<Rect> a, shared_ptr<Rect> b) {
            return a->GetAcreage() > b->GetAcreage();
            });

        Rect container = Rect(plot->GetSizeX() / 2, plot->GetSizeY() / 2, plot->GetSizeX(), plot->GetSizeY());
        if (elements.size() == 1) {
            elements[0]->SetPosition(container.GetPosX(), container.GetPosY(), container.GetSizeX(), container.GetSizeY());
        }
        else {
            class Chunk : public Rect {
            public:
                Chunk(shared_ptr<Rect> r1, shared_ptr<Rect> r2) : r1(r1), r2(r2) { acreage = r1->GetAcreage() + r2->GetAcreage(); }
                shared_ptr<Rect> r1, r2;
            };
            while (elements.size() > 2) {
                shared_ptr<Chunk> tmp = make_shared<Chunk>(elements[elements.size() - 1], elements[elements.size() - 2]);
                elements.pop_back();
                int i = (int)elements.size() - 2;
                for (; i >= 0; i--) {
                    if (tmp->GetAcreage() > elements[i]->GetAcreage()) {
                        elements[i + 1] = elements[i];
                    }
                    else {
                        elements[i + 1] = tmp;
                        break;
                    }
                }
                if (i < 0)elements[0] = tmp;
            }

            if (container.GetSizeX() > container.GetSizeY()) {
                if (GetRandom(2)) {
                    int divX = int(container.GetLeft() +
                        (container.GetRight() - container.GetLeft()) * elements[0]->GetAcreage() / container.GetAcreage());
                    if (abs(divX - container.GetLeft()) < 2)divX = (int)container.GetLeft();
                    if (abs(divX - container.GetRight()) < 2)divX = (int)container.GetRight();
                    elements[0]->SetVertices(container.GetLeft(), container.GetBottom(), (float)divX, container.GetTop());
                    elements[1]->SetVertices((float)divX, container.GetBottom(), container.GetRight(), container.GetTop());
                }
                else {
                    int divX = int(container.GetLeft() +
                        (container.GetRight() - container.GetLeft()) * elements[1]->GetAcreage() / container.GetAcreage());
                    if (abs(divX - container.GetLeft()) < 2)divX = (int)container.GetLeft();
                    if (abs(divX - container.GetRight()) < 2)divX = (int)container.GetRight();
                    elements[1]->SetVertices(container.GetLeft(), container.GetBottom(), (float)divX, container.GetTop());
                    elements[0]->SetVertices((float)divX, container.GetBottom(), container.GetRight(), container.GetTop());
                }
            }
            else {
                if (GetRandom(2)) {
                    int divY = int(container.GetBottom() +
                        (container.GetTop() - container.GetBottom()) * elements[0]->GetAcreage() / container.GetAcreage());
                    if (abs(divY - container.GetBottom()) < 2)divY = (int)container.GetBottom();
                    if (abs(divY - container.GetTop()) < 2)divY = (int)container.GetTop();
                    elements[0]->SetVertices(container.GetLeft(), container.GetBottom(), container.GetRight(), (float)divY);
                    elements[1]->SetVertices(container.GetLeft(), (float)divY, container.GetRight(), container.GetTop());
                }
                else {
                    int divY = int(container.GetBottom() +
                        (container.GetTop() - container.GetBottom()) * elements[1]->GetAcreage() / container.GetAcreage());
                    if (abs(divY - container.GetBottom()) < 2)divY = (int)container.GetBottom();
                    if (abs(divY - container.GetTop()) < 2)divY = (int)container.GetTop();
                    elements[1]->SetVertices(container.GetLeft(), container.GetBottom(), container.GetRight(), (float)divY);
                    elements[0]->SetVertices(container.GetLeft(), (float)divY, container.GetRight(), container.GetTop());
                }
            }

            while (elements.size() > 0) {
                auto tmp = elements.back();
                elements.pop_back();
                if (auto chunk = dynamic_pointer_cast<Chunk>(tmp)) {
                    shared_ptr<Rect> rect1 = chunk->r1;
                    shared_ptr<Rect> rect2 = chunk->r2;

                    if (tmp->GetAcreage() > 0) {
                        if (tmp->GetSizeX() > tmp->GetSizeY()) {
                            if (GetRandom(2)) {
                                int divX = int(tmp->GetLeft() +
                                    tmp->GetSizeX() * rect1->GetAcreage() / tmp->GetAcreage());
                                if (abs(divX - tmp->GetLeft()) < 2)divX = (int)tmp->GetLeft();
                                if (abs(divX - tmp->GetRight()) < 2)divX = (int)tmp->GetRight();
                                rect1->SetVertices(tmp->GetLeft(), tmp->GetBottom(), (float)divX, tmp->GetTop());
                                rect2->SetVertices((float)divX, tmp->GetBottom(), tmp->GetRight(), tmp->GetTop());
                            }
                            else {
                                int divX = int(tmp->GetLeft() +
                                    tmp->GetSizeX() * rect2->GetAcreage() / tmp->GetAcreage());
                                if (abs(divX - tmp->GetLeft()) < 2)divX = (int)tmp->GetLeft();
                                if (abs(divX - tmp->GetRight()) < 2)divX = (int)tmp->GetRight();
                                rect2->SetVertices(tmp->GetLeft(), tmp->GetBottom(), (float)divX, tmp->GetTop());
                                rect1->SetVertices((float)divX, tmp->GetBottom(), tmp->GetRight(), tmp->GetTop());
                            }
                        }
                        else {
                            if (GetRandom(2)) {
                                int divY = int(tmp->GetBottom() +
                                    tmp->GetSizeY() * rect1->GetAcreage() / tmp->GetAcreage());
                                if (abs(divY - tmp->GetBottom()) < 2)divY = (int)tmp->GetBottom();
                                if (abs(divY - tmp->GetTop()) < 2)divY = (int)tmp->GetTop();
                                rect1->SetVertices(tmp->GetLeft(), tmp->GetBottom(), tmp->GetRight(), (float)divY);
                                rect2->SetVertices(tmp->GetLeft(), (float)divY, tmp->GetRight(), tmp->GetTop());
                            }
                            else {
                                int divY = int(tmp->GetBottom() +
                                    tmp->GetSizeY() * rect2->GetAcreage() / tmp->GetAcreage());
                                if (abs(divY - tmp->GetBottom()) < 2)divY = (int)tmp->GetBottom();
                                if (abs(divY - tmp->GetTop()) < 2)divY = (int)tmp->GetTop();
                                rect2->SetVertices(tmp->GetLeft(), tmp->GetBottom(), tmp->GetRight(), (float)divY);
                                rect1->SetVertices(tmp->GetLeft(), (float)divY, tmp->GetRight(), tmp->GetTop());
                            }
                        }
                        if (dynamic_pointer_cast<Chunk>(rect1))elements.push_back(rect1);
                        if (dynamic_pointer_cast<Chunk>(rect2))elements.push_back(rect2);
                    }
                }
            }
        }
    }
}





// ===== .\Forever\map.h =====

﻿#pragma once

#include "terrain.h"
#include "roadnet.h"
#include "zone.h"
#include "building.h"
#include "component.h"
#include "room.h"
#include "person.h"
#include "change.h"
#include "script.h"

#include <windows.h>

#define BLOCK_SIZE 256


class Element {
public:
	Element() = default;
	~Element() = default;

	//获取/设置地形名称
	std::string GetTerrain() const;
	bool SetTerrain(std::string terrain);

	//获取/设置园区标识
	std::string GetZone() const;
	bool SetZone(std::string zone);

	//获取/设置建筑标识
	std::string GetBuilding() const;
	bool SetBuilding(std::string building);

private:
	std::string terrain = "plain";
	std::string zone;
	std::string building;
};

class Block {
public:
	Block() = delete;
	Block(int x, int y);
	~Block();

	//获取/设置地形名称
	std::string GetTerrain(int x, int y) const;
	bool SetTerrain(int x, int y, std::string terrain);

	//检查全局坐标是否在地块内
	bool CheckXY(int x, int y) const;

	//获取地块内某全局坐标的信息
	std::shared_ptr<Element> GetElement(int x, int y);

private:
	// 基础内容
	int offsetX, offsetY;
	std::vector<std::vector<std::shared_ptr<Element>>> elements;
};

class Map {
public:
	Map();
	~Map();

	// 读取Mods
	void InitTerrains();
	void InitRoadnets();
	void InitZones();
	void InitBuildings();
	void InitComponents();
	void InitRooms();

	// 读取配置文件
	void ReadConfigs(std::string path) const;

	// 初始化全部静态地图
	int Init(int blockX, int blockY);

	// 市民入驻
	void Checkin(std::vector<std::shared_ptr<Person>> citizens, Time time);

	// 释放空间
	void Destroy();

	// 时钟前进
	void Tick();

	// 输出当前地图
	void Print();

	// 应用变更
	void ApplyChange(std::shared_ptr<Change> change, std::unique_ptr<Script>& script);

	// 保存/加载地图
	void Load(std::string path);
	void Save(std::string path);

	// 获取地图尺寸
	std::pair<int, int> GetSize();

	// 检查全局坐标是否在地图内
	bool CheckXY(int x, int y) const;

	// 获取地块
	std::shared_ptr<Block> GetBlock(int x, int y) const;

	// 获取元素
	std::shared_ptr<Element> GetElement(int x, int y) const;

	// 获取路网
	std::shared_ptr<Roadnet> GetRoadnet() const;

	// 获取组合
	std::vector<std::shared_ptr<Component>> GetComponents() const;

	// 获取/设置元素所属园区/建筑
	std::shared_ptr<Zone> GetZone(std::string name);
	std::shared_ptr<Building> GetBuilding(std::string name);
	void SetZone(std::shared_ptr<Zone> zone, std::string name);
	void SetBuilding(std::shared_ptr<Building> building, std::string name);
	void SetBuilding(std::shared_ptr<Building> building, std::string name, std::pair<float, float> offset);

private:
	// Mod管理
	std::vector<HMODULE> modHandles;
	std::unique_ptr<TerrainFactory> terrainFactory;
	std::unique_ptr<RoadnetFactory> roadnetFactory;
	std::unique_ptr<ZoneFactory> zoneFactory;
	std::unique_ptr<BuildingFactory> buildingFactory;
	std::unique_ptr<ComponentFactory> componentFactory;
	std::unique_ptr<RoomFactory> roomFactory;

	// 基础内容
	int width = 0, height = 0;
	std::vector<std::vector<std::shared_ptr<Block>>> blocks;

	// 地图架构
	std::shared_ptr<Roadnet> roadnet;
	std::unordered_map<std::string, std::shared_ptr<Zone>> zones;
	std::unordered_map<std::string, std::shared_ptr<Building>> buildings;
	std::unique_ptr<Layout> layout;

	// 获取/设置地形名称
	std::string GetTerrain(int x, int y) const;
	bool SetTerrain(int x, int y, std::string terrain);

	// 排列地块中的园区与建筑
	void ArrangePlots();
};



// ===== .\Forever\milestone.cpp =====

﻿#include "milestone.h"


using namespace std;

Milestone::Milestone(string name, shared_ptr<Event> trigger, bool visible, Condition drop,
	string description, string goal, vector<Dialog> dialogs, vector<shared_ptr<Change>> changes) :
	name(name), trigger(trigger), visible(visible), drop(drop),
	description(description), goal(goal), dialogs(dialogs), changes(changes) {

}

Milestone::~Milestone() {

}

vector<Dialog> Milestone::GetDialogs() {
	return dialogs;
}

vector<shared_ptr<Change>> Milestone::GetChanges() {
	return changes;
}

shared_ptr<Event> Milestone::GetTrigger() {
	return trigger;
}

bool Milestone::MatchTrigger(shared_ptr<Event> e) {
	if (!trigger)return false;
	if (!e)return false;
	if (trigger->GetType() != e->GetType())return false;

	return trigger->operator==(e);
}

string Milestone::GetName() {
	return name;
}

bool Milestone::IsVisible() {
	return visible;
}

bool Milestone::DropSelf(function<ValueType(const string&)> getValue) {
	return drop.EvaluateBool(getValue);
}

string Milestone::GetDescription() {
	return description;
}

string Milestone::GetGoal() {
	return goal;
}

MilestoneNode::MilestoneNode(Milestone milestone) : content(milestone) {

}



// ===== .\Forever\milestone.h =====

﻿#pragma once

#include "utility.h"
#include "dialog.h"
#include "change.h"
#include "event.h"

#include <string>


class Milestone {
public:
    Milestone(std::string name, std::shared_ptr<Event> trigger, bool visible, Condition keep,
        std::string description, std::string goal, std::vector<Dialog> dialogs, std::vector<std::shared_ptr<Change>> changes);
    ~Milestone();

    // 复合对象类型
    std::shared_ptr<Event> GetTrigger();
    std::vector<Dialog> GetDialogs();
    std::vector<std::shared_ptr<Change>> GetChanges();

    // 匹配事件
    bool MatchTrigger(std::shared_ptr<Event> e);

    // 获取参数
    std::string GetName();
    bool IsVisible();
    bool DropSelf(std::function<ValueType(const std::string&)> getValue);
    std::string GetDescription();
    std::string GetGoal();

private:
    std::string name;
    std::shared_ptr<Event> trigger;
    bool visible;
    Condition drop;
    std::string description;
    std::string goal;
    std::vector<Dialog> dialogs;
    std::vector<std::shared_ptr<Change>> changes;
};

class MilestoneNode {
public:
	MilestoneNode(Milestone milestone);

	Milestone content;

    // 前置数量
	int premise = 0;

    // 后置里程碑
	std::vector<MilestoneNode *> subsequents;
};


// ===== .\Forever\name.cpp =====

﻿#include "job.h"
#include "name.h"
#include "utility.h"


using namespace std;

TestName::TestName() {
    InitializeSurnames();
    InitializeNames();
}

TestName::~TestName() {

}

// 初始化姓氏列表
void TestName::InitializeSurnames() {
    surnames = {
        "王", "李", "张", "刘", "陈", "杨", "赵", "黄", "周", "吴",
        "徐", "孙", "胡", "朱", "高", "林", "何", "郭", "马", "罗",
        "梁", "宋", "郑", "谢", "韩", "唐", "冯", "于", "董", "萧",
        "程", "曹", "袁", "邓", "许", "傅", "沈", "曾", "彭", "吕",
        "苏", "卢", "蒋", "蔡", "贾", "丁", "魏", "薛", "叶", "阎",
        "余", "潘", "杜", "戴", "夏", "钟", "汪", "田", "任", "姜",
        "范", "方", "石", "姚", "谭", "廖", "邹", "熊", "金", "陆",
        "郝", "孔", "白", "崔", "康", "毛", "邱", "秦", "江", "史",
        "顾", "侯", "邵", "孟", "龙", "万", "段", "雷", "钱", "汤",
        "尹", "黎", "易", "常", "武", "乔", "贺", "赖", "龚", "文",
        "庞", "樊", "兰", "殷", "施", "陶", "洪", "翟", "安", "颜",
        "倪", "严", "牛", "温", "芦", "季", "俞", "章", "鲁", "葛",
        "伍", "韦", "申", "尤", "毕", "聂", "丛", "焦", "向", "柳",
        "邢", "路", "岳", "齐", "沿", "梅", "莫", "庄", "辛", "管",
        "祝", "左", "涂", "谷", "祁", "时", "舒", "耿", "牟", "卜",
        "路", "詹", "关", "苗", "凌", "费", "纪", "靳", "盛", "童",
        "欧", "甄", "项", "曲", "成", "游", "阳", "裴", "席", "卫",
        "查", "屈", "鲍", "位", "覃", "霍", "翁", "隋", "植", "甘",
        "景", "薄", "单", "包", "司", "柏", "宁", "柯", "阮", "桂",
        "闵", "欧阳", "解", "强", "柴", "华", "车", "冉", "房", "边",
        "辜", "吉", "饶", "刁", "瞿", "戚", "丘", "古", "米", "池",
        "滕", "晋", "苑", "邬", "臧", "畅", "宫", "来", "嵺", "苟",
        "全", "褚", "廉", "简", "娄", "盖", "符", "奚", "木", "穆",
        "党", "燕", "郎", "邸", "冀", "谈", "姬", "屠", "连", "郜",
        "晏", "栾", "郁", "商", "蒙", "计", "喻", "揭", "窦", "迟",
        "宇", "敖", "糜", "鄢", "冷", "卓", "花", "仇", "艾", "蓝"
    };
}

// 初始化名字列表
void TestName::InitializeNames() {
    maleNames = {
        "伟", "强", "勇", "军", "磊", "洋", "超", "健", "明", "涛",
        "鹏", "华", "亮", "刚", "杰", "峰", "建", "波", "浩", "凯",
        "帅", "晨", "龙", "阳", "剑", "博", "飞", "达", "宏", "斌",
        "辉", "昊", "栋", "锋", "睿", "彬", "旭", "豪", "翔", "坤",
        "诚", "清", "伦", "勋", "铭", "扬", "皓", "越", "渊", "楠",
        "祺", "航", "宇", "涵", "辰", "奕", "霖", "煊", "宸", "昱",
        "轩", "贤", "智", "楷", "远", "弘", "松", "哲", "瀚", "圣",
        "云", "懿", "维", "风", "运", "晟", "佑", "炫", "舟", "南",
        "岩", "野", "祥", "仁", "雨", "世", "昌", "翰", "泰", "泽",
        "民", "鸣", "志", "树", "林", "森", "朴", "梁", "柯", "桂",
        "业", "果", "猛", "威", "彪", "雄", "武", "胜", "力", "壮",
        "山", "海", "河", "江", "川", "岳", "石", "铁", "金", "锐",
        "利", "战", "斗", "霸", "王", "帝", "君", "将", "帅", "毅",
        "决", "行", "动", "跃", "腾", "升", "起", "冲", "闯", "奔"
    };

    femaleNames = {
        "芳", "娜", "敏", "静", "丽", "艳", "娟", "玲", "霞", "燕",
        "颖", "洁", "琳", "婷", "莹", "欣", "琼", "倩", "慧", "琪",
        "瑜", "梅", "雪", "蕾", "雯", "怡", "璇", "妍", "玥", "璐",
        "娅", "琦", "晶", "瑶", "蓓", "仪", "荷", "丹", "蓉", "君",
        "琴", "蕊", "薇", "菁", "梦", "苑", "婕", "馨", "韵", "园",
        "艺", "卿", "聪", "澜", "纯", "昭", "冰", "爽", "羽", "希",
        "宁", "飘", "滢", "柔", "竹", "凝", "晓", "欢", "芸", "菲",
        "寒", "伊", "亚", "宜", "可", "舒", "影", "思", "秀", "英",
        "华", "巧", "美", "淑", "惠", "珠", "翠", "雅", "芝", "玉",
        "萍", "红", "娥", "芬", "彩", "春", "菊", "兰", "凤", "素",
        "莲", "真", "环", "爱", "妹", "香", "月", "莺", "媛", "瑞"
    };

    neutralNames = {
        "安", "宁", "睿", "悦", "乐", "佳", "子", "思", "晓", "凡",
        "嘉", "宇", "晨", "雨", "欣", "梓", "涵", "梦", "云", "阳",
        "文", "笑", "一", "心", "亦", "若", "凌", "之", "景", "清",
        "秋", "诗", "灵", "白", "忆", "元", "初", "平", "寒", "问",
        "雁", "夜", "山", "如", "南", "书", "寻", "千", "风", "尔",
        "友", "谷", "以", "念", "冷", "依", "碧", "惜", "静", "度",
        "新", "笑", "怀", "天", "从", "语", "烟", "访", "落", "翠",
        "欲", "闲", "惊", "眠", "听", "然", "辰", "奕", "霖", "昊",
        "智", "渊", "瑞", "云", "诚", "维", "运", "琪", "佑", "炫",
        "南", "瑾", "遥", "仁", "韵", "辉", "玮", "光", "和", "平",
        "顺", "利", "通", "达", "显", "扬", "发", "展", "开", "放"
    };
}

string TestName::GetSurname(std::string name) {
    return name.substr(0, 2);
}

string TestName::GenerateName(bool male, bool female, bool neutral) {
    string surname = surnames[GetRandom((int)surnames.size())];

    string givenName;
    vector<int> nameList;

    nameList.push_back(male ? (int)maleNames.size() : 0);
    nameList.push_back(female ? (int)femaleNames.size() : 0);
    nameList.push_back(neutral ? (int)neutralNames.size() : 0);

    int nameLength = 1 + (bool)GetRandom(9);
    int listLength = nameList[0] + nameList[1] + nameList[2];

    if (listLength == 0) {
        neutral = true;
        nameList[2] = (int)neutralNames.size();
        listLength = (int)neutralNames.size();
    }

    for (int i = 0; i < nameLength; ++i) {
        int idx = GetRandom(listLength);
        if (idx < nameList[0]) {
            givenName += maleNames[idx];
        }
        else {
            idx -= nameList[0];
            if (idx < nameList[1]) {
                givenName += femaleNames[idx];
            }
            else {
                idx -= nameList[1];
                givenName += neutralNames[idx];
            }
        }
    }

    return surname + givenName;
}

string TestName::GenerateName(string surname, bool male, bool female, bool neutral) {
    string givenName;
    vector<int> nameList;

    nameList.push_back(male ? (int)maleNames.size() : 0);
    nameList.push_back(female ? (int)femaleNames.size() : 0);
    nameList.push_back(neutral ? (int)neutralNames.size() : 0);

    int nameLength = 1 + (bool)GetRandom(9);
    int listLength = nameList[0] + nameList[1] + nameList[2];

    if (listLength == 0) {
        neutral = true;
        nameList[2] = (int)neutralNames.size();
        listLength = (int)neutralNames.size();
    }

    for (int i = 0; i < nameLength; ++i) {
        int idx = GetRandom(listLength);
        if (idx < nameList[0]) {
            givenName += maleNames[idx];
        }
        else {
            idx -= nameList[0];
            if (idx < nameList[1]) {
                givenName += femaleNames[idx];
            }
            else {
                idx -= nameList[1];
                givenName += neutralNames[idx];
            }
        }
    }

    return surname + givenName;
}


// ===== .\Forever\name.h =====

﻿#pragma once

#include "name_base.h"


// 子类注册函数
typedef void (*RegisterModNamesFunc)(NameFactory* factory);

// 主程序检测子类
class TestName : public Name {
public:
    TestName();
    ~TestName();

    static std::string GetId() { return "chinese"; }
    virtual std::string GetType() const override { return "chinese"; }
    virtual std::string GetName() const override { return "中文姓名"; }

    virtual std::string GetSurname(std::string name) override;
    virtual std::string GenerateName(bool male = true, bool female = true, bool neutral = true) override;
    virtual std::string GenerateName(std::string surname, bool male = true, bool female = true, bool neutral = true) override;

private:
    std::vector<std::string> surnames;
    std::vector<std::string> maleNames;
    std::vector<std::string> femaleNames;
    std::vector<std::string> neutralNames;

    void InitializeSurnames();
    void InitializeNames();

};


// ===== .\Forever\organization.cpp =====

﻿#include "organization.h"


using namespace std;



// ===== .\Forever\organization.h =====

﻿#pragma once

#include "../map/component_base.h"
#include "../populace/job_base.h"
#include "organization_base.h"


// 子类注册函数
typedef void (*RegisterModOrganizationsFunc)(OrganizationFactory* factory);

// 主程序检测子类
class TestOrganization : public Organization {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试组织"; }

    static float GetPower() {
        return 1.0f;
    }

    virtual std::vector<std::pair<std::string, std::pair<int, int>>> ComponentRequirements() const override {
        std::vector<std::pair<std::string, std::pair<int, int>>> requirements;
		requirements.emplace_back("test", std::make_pair(1, 3));

		return requirements;
    }

    virtual std::vector<std::pair<std::string, std::vector<std::string>>> ArrageVacancies(
        std::vector<std::pair<std::string, int>> components) const override {
        std::vector<std::pair<std::string, std::vector<std::string>>> jobs;
        for(auto& comp : components) {
            jobs.emplace_back(comp.first, std::vector<std::string>(comp.second, "test"));
		}

		return jobs;
    }

    virtual void SetCalendar(CalendarFactory* factory) override {
        for (auto component : jobs) {
            for (auto job : component.second) {
                std::shared_ptr<Calendar> calendar = factory->CreateCalendar("test");
                job.first->SetCalendar(calendar);
            }
        }
    }

};




// ===== .\Forever\person.cpp =====

﻿#include "person.h"


using namespace std;

Person::Person() {

}

Person::~Person() {

}

int Person::GetId() const {
	return id;
}

void Person::SetId(int id) {
	this->id = id;
}

const string& Person::GetName() const {
	return name;
}

void Person::SetName(const string& name) {
	this->name = name;
}

GENDER_TYPE Person::GetGender() const {
	return gender;
}

void Person::SetGender(GENDER_TYPE gender) {
	this->gender = gender;
}

float Person::GetHeight() const {
	return height;
}

void Person::SetHeight(float height) {
	this->height = height;
}

float Person::GetWeight() const {
	return weight;
}

void Person::SetWeight(float weight) {
	this->weight = weight;
}

const Time& Person::GetBirthday() const {
	return birthday;
}

void Person::SetBirthday(const Time& birthday) {
	this->birthday = birthday;
}

int Person::GetAge(const Time& currentTime) const {
	int age = currentTime.GetYear() - birthday.GetYear();
	if (currentTime.GetMonth() < birthday.GetMonth() ||
		(currentTime.GetMonth() == birthday.GetMonth() && currentTime.GetDay() < birthday.GetDay())) {
		age--;
	}
	return age;
}

const Time& Person::GetMarryday() const {
	return marryday;
}

void Person::SetMarryday(const Time& marryday) {
	this->marryday = marryday;
}

const string& Person::GetNick() const {
	return nick;
}

void Person::SetNick(const string& nick) {
	this->nick = nick;
}

int Person::GetDeposit() const {
	return deposit;
}

void Person::SetDeposit(int deposit) {
	this->deposit = deposit;
}

int Person::GetPhone() const {
	return phone;
}

void Person::SetPhone(int phone) {
	this->phone = phone;
}

int Person::GetSimulate() const {
	return simulate;
}

void Person::SetSimulate(int simulate) {
	this->simulate = simulate;
}

void Person::AddRelative(RELATIVE_TYPE type, shared_ptr<Person> person) {
	relatives.push_back(make_pair(type, person));
}

shared_ptr<Person> Person::GetFather() {
	for (auto relative : relatives) {
		if (relative.first == RELATIVE_FATHER)return relative.second;
	}
	return nullptr;
}

shared_ptr<Person> Person::GetMother() {
	for (auto relative : relatives) {
		if (relative.first == RELATIVE_MOTHER)return relative.second;
	}
	return nullptr;
}

shared_ptr<Person> Person::GetSpouse() {
	for (auto relative : relatives) {
		if (relative.first == RELATIVE_WIFE || relative.first == RELATIVE_HUSBAND)return relative.second;
	}

	return nullptr;
}

vector<shared_ptr<Person>> Person::GetChilds() {
	vector<shared_ptr<Person>>childs;
	for (auto relative : relatives) {
		if (relative.first == RELATIVE_SON || relative.first == RELATIVE_DAUGHTER)childs.push_back(relative.second);
	}
	return childs;
}

void Person::AddAsset(std::shared_ptr<Asset> asset) {
	assets.push_back(asset);
}

std::vector<std::shared_ptr<Asset>>& Person::GetAssets() {
	return assets;
}

std::vector<std::shared_ptr<Asset>> Person::GetAssets(std::string type) {
	std::vector<std::shared_ptr<Asset>> results;

	for (auto& asset : assets) {
		if (asset->GetType() == type) {
			results.push_back(asset);
		}
	}

	return results;
}

std::shared_ptr<Asset> Person::GetAsset(std::string name) {
	for (auto& asset : assets) {
		if (asset->GetName() == name) {
			return asset;
		}
	}

	return nullptr;
}

vector<shared_ptr<Job>> Person::GetJobs() {
	return jobs;
}

void Person::AddJob(shared_ptr<Job> job) {
	jobs.push_back(job);
}

void Person::RemoveJob(std::shared_ptr<Job> job) {
	for (auto &j : jobs) {
		if (j == job) {
			j = *jobs.end();
			jobs.pop_back();
			break;
		}
	}
}

shared_ptr<Room> Person::GetHome() {
	return home;
}

void Person::SetHome(std::shared_ptr<Room> room) {
	home = room;
}

void Person::RemoveHome() {
	home = nullptr;
}

shared_ptr<Scheduler> Person::GetScheduler() {
	return scheduler;
}

void Person::SetScheduler(std::shared_ptr<Scheduler> scheduler) {
	this->scheduler = scheduler;
}

void Person::AddEducationExperience(EducationExperience exp) {
	educationExperiences.push_back(exp);
}

void Person::AddEmotionExperience(EmotionExperience exp) {
	emotionExperiences.push_back(exp);
}

void Person::AddJobExperience(JobExperience exp) {
	jobExperiences.push_back(exp);
}

vector<EducationExperience>& Person::GetEducationExperiences() {
	return educationExperiences;
}

vector<EmotionExperience>& Person::GetEmotionExperiences() {
	return emotionExperiences;
}

vector<JobExperience>& Person::GetJobExperiences() {
	return jobExperiences;
}

void Person::ExperienceComposition() {
	if (educationExperiences.size() == 0)return;

	int idx = 0;
	EducationExperience education = educationExperiences[0];
	for (int i = 1; i < educationExperiences.size(); i++) {
		if (education.GetSchool() == educationExperiences[i].GetSchool() &&
			education.GetEndTime().GetYear() == educationExperiences[i].GetBeginTime().GetYear()) {
			education.SetTime(education.GetBeginTime(), educationExperiences[i].GetEndTime());
			education.SetGraduate(educationExperiences[i].GetGraduate());
		}
		else {
			educationExperiences[idx++] = education;
			education = educationExperiences[i];
		}
	}
	educationExperiences[idx++] = education;
	educationExperiences.resize(idx);
}



// ===== .\Forever\person.h =====

﻿#pragma once

#include "asset.h"
#include "scheduler.h"
#include "job.h"
#include "experience.h"
#include "utility.h"

#include <string>
#include <memory>
#include <vector>

#undef GetJob
#undef AddJob


class EducationExperience;
class EmotionExperience;
class JobExperience;

enum GENDER_TYPE {
	GENDER_FEMALE, // 女性
	GENDER_MALE // 男性
};

enum RELATIVE_TYPE {
	RELATIVE_FATHER, // 父亲
	RELATIVE_MOTHER, // 母亲
	RELATIVE_WIFE, // 妻子
	RELATIVE_HUSBAND, // 丈夫
	RELATIVE_SON, // 儿子
	RELATIVE_DAUGHTER // 女儿
};

class Person {
public:
	Person();
	~Person();

	// 获取/设置基础信息
	int GetId() const;
	void SetId(int id);
	const std::string& GetName() const;
	void SetName(const std::string& name);
	GENDER_TYPE GetGender() const;
	void SetGender(GENDER_TYPE gender);
	float GetHeight() const;
	void SetHeight(float height);
	float GetWeight() const;
	void SetWeight(float weight);
	const Time& GetBirthday() const;
	void SetBirthday(const Time& birthday);
	int GetAge(const Time& currentTime) const;
	const Time& GetMarryday() const;
	void SetMarryday(const Time& marryday);
	const std::string& GetNick() const;
	void SetNick(const std::string& nick);
	int GetDeposit() const;
	void SetDeposit(int deposit);
	int GetPhone() const;
	void SetPhone(int phone);

	// 实时模拟
	int GetSimulate() const;
	void SetSimulate(int simulate);

	// 管理亲属
	void AddRelative(RELATIVE_TYPE type, std::shared_ptr<Person> person);
	std::shared_ptr<Person> GetFather();
	std::shared_ptr<Person> GetMother();
	std::shared_ptr<Person> GetSpouse();
	std::vector<std::shared_ptr<Person>> GetChilds();

	// 管理资产
	void AddAsset(std::shared_ptr<Asset> asset);
	std::vector<std::shared_ptr<Asset>>& GetAssets();
	std::vector<std::shared_ptr<Asset>> GetAssets(std::string name);
	std::shared_ptr<Asset> GetAsset(std::string name);

	// 管理职业
	std::vector<std::shared_ptr<Job>> GetJobs();
	void AddJob(std::shared_ptr<Job> job);
	void RemoveJob(std::shared_ptr<Job> job);

	// 管理住址
	std::shared_ptr<Room> GetHome();
	void SetHome(std::shared_ptr<Room> room);
	void RemoveHome();

	// 管理调度
	std::shared_ptr<Scheduler> GetScheduler();
	void SetScheduler(std::shared_ptr<Scheduler> scheduler);

	// 管理经历
	void AddEducationExperience(EducationExperience exp);
	void AddEmotionExperience(EmotionExperience exp);
	void AddJobExperience(JobExperience exp);
	std::vector<EducationExperience>& GetEducationExperiences();
	std::vector<EmotionExperience>& GetEmotionExperiences();
	std::vector<JobExperience>& GetJobExperiences();
	void ExperienceComposition();

private:
	int id;
	std::string name;
	GENDER_TYPE gender;
	Time birthday;
	Time marryday;
	float height, weight;
	std::string nick;
	int deposit;
	int phone;

	bool simulate = true;

	std::vector<std::pair<RELATIVE_TYPE, std::shared_ptr<Person>>> relatives;

	std::vector<std::shared_ptr<Asset>> assets;
	std::vector<std::shared_ptr<Job>> jobs;

	std::shared_ptr<Room> home;
	std::shared_ptr<Scheduler> scheduler;

	std::vector<EducationExperience> educationExperiences;
	std::vector<EmotionExperience> emotionExperiences;
	std::vector<JobExperience> jobExperiences;
};

// ===== .\Forever\populace.cpp =====

﻿#include "utility.h"
#include "error.h"
#include "populace.h"
#include "json.h"

#include <fstream>
#include <filesystem>
#include <algorithm>
#include <cmath>
#include <random>


using namespace std;

Populace::Populace() {
	assetFactory.reset(new AssetFactory());
    jobFactory.reset(new JobFactory());
	nameFactory.reset(new NameFactory());
	schedulerFactory.reset(new SchedulerFactory());
}

Populace::~Populace() {
    for (auto& mod : modHandles) {
        if (mod) {
            FreeLibrary(mod);
        }
    }
    modHandles.clear();
}

void Populace::InitAssets() {
	assetFactory->RegisterAsset(TestAsset::GetId(), []() { return make_unique<TestAsset>(); });

	HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
	if (modHandle) {
		modHandles.push_back(modHandle);
		debugf("Mod dll loaded successfully.\n");

		RegisterModAssetsFunc registerFunc = (RegisterModAssetsFunc)GetProcAddress(modHandle, "RegisterModAssets");
		if (registerFunc) {
			registerFunc(assetFactory.get());
		}
		else {
			debugf("Incorrect dll content.");
		}
	}
	else {
		debugf("Failed to load mod.dll.");
	}

#ifdef MOD_TEST
	auto assetList = { "test", "mod" };
	for (const auto& assetId : assetList) {
		if (assetFactory->CheckRegistered(assetId)) {
			auto asset = assetFactory->CreateAsset(assetId);
			debugf(("Created asset: " + asset->GetName() + " (ID: " + assetId + ")\n").data());
		}
		else {
			debugf("Asset not registered: %s\n", assetId);
		}
	}
#endif // MOD_TEST

}

void Populace::InitJobs() {
    jobFactory->RegisterJob(TestJob::GetId(), []() { return make_unique<TestJob>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModJobsFunc registerFunc = (RegisterModJobsFunc)GetProcAddress(modHandle, "RegisterModJobs");
        if (registerFunc) {
            registerFunc(jobFactory.get());
        }
        else {
            debugf("Incorrect dll content.");
        }
    }
    else {
        debugf("Failed to load mod.dll.");
    }

#ifdef MOD_TEST
    auto jobList = { "test", "mod" };
    for (const auto& jobId : jobList) {
        if (jobFactory->CheckRegistered(jobId)) {
            auto job = jobFactory->CreateJob(jobId);
            debugf(("Created job: " + job->GetName() + " (ID: " + jobId + ")\n").data());
        }
        else {
            debugf("Job not registered: %s\n", jobId);
        }
    }
#endif // MOD_TEST

}

void Populace::InitNames() {
	nameFactory->RegisterName(TestName::GetId(), []() { return make_unique<TestName>(); });

	HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
	if (modHandle) {
		modHandles.push_back(modHandle);
		debugf("Mod dll loaded successfully.\n");

		RegisterModNamesFunc registerFunc = (RegisterModNamesFunc)GetProcAddress(modHandle, "RegisterModNames");
		if (registerFunc) {
			registerFunc(nameFactory.get());
		}
		else {
			debugf("Incorrect dll content.");
		}
	}
	else {
		debugf("Failed to load mod.dll.");
	}

#ifdef MOD_TEST
	auto nameList = { "chinese", "mod" };
	for (const auto& nameId : nameList) {
		if (nameFactory->CheckRegistered(nameId)) {
			auto name = nameFactory->CreateName(nameId);
			debugf(("Created name: " + name->GetName() + " (ID: " + nameId + ")\n").data());
		}
		else {
			debugf("Name not registered: %s\n", nameId);
		}
	}
#endif // MOD_TEST

}

void Populace::InitSchedulers() {
	schedulerFactory->RegisterScheduler(TestScheduler::GetId(),
		[]() { return make_unique<TestScheduler>(); }, TestScheduler::GetPower());

	HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
	if (modHandle) {
		modHandles.push_back(modHandle);
		debugf("Mod dll loaded successfully.\n");

		RegisterModSchedulersFunc registerFunc = (RegisterModSchedulersFunc)GetProcAddress(modHandle, "RegisterModSchedulers");
		if (registerFunc) {
			registerFunc(schedulerFactory.get());
		}
		else {
			debugf("Incorrect dll content.");
		}
	}
	else {
		debugf("Failed to load mod.dll.");
	}

#ifdef MOD_TEST
	auto schedulerList = { "test", "mod" };
	for (const auto& schedulerId : schedulerList) {
		if (schedulerFactory->CheckRegistered(schedulerId)) {
			auto scheduler = schedulerFactory->CreateScheduler(schedulerId);
			debugf(("Created scheduler: " + scheduler->GetName() + " (ID: " + schedulerId + ")\n").data());
		}
		else {
			debugf("Scheduler not registered: %s\n", schedulerId);
		}
	}
#endif // MOD_TEST

}

void Populace::ReadConfigs(string path) const {
    if (!filesystem::exists(path)) {
        THROW_EXCEPTION(IOException, "Path does not exist: " + path + ".\n");
    }

    Json::Reader reader;
    Json::Value root;

    ifstream fin(path);
    if (!fin.is_open()) {
        THROW_EXCEPTION(IOException, "Failed to open file: " + path + ".\n");
    }
    if (reader.parse(fin, root)) {
		for (auto job : root["mods"]["job"]) {
			jobFactory->SetConfig(job.asString(), true);
		}
		nameFactory->SetConfig(root["mods"]["name"].asString(), true);
    }
    else {
        fin.close();
        THROW_EXCEPTION(JsonFormatException, "Json syntax error: " + reader.getFormattedErrorMessages() + ".\n");
    }
    fin.close();
}

void Populace::Init(int accomodation) {
    // 生成市民
    GenerateCitizens((int)(accomodation * exp(GetRandom(1000) / 1000.0f - 0.5f)));

	// 生成经历
	GenerateEducations();
	GenerateEmotions();
	GenerateJobs();
}

void Populace::Schedule() {
	auto powers = schedulerFactory->GetPowers();
	vector<pair<string, float>> cdfs;
	float sum = 0.f;
	for (auto power : powers) {
		sum += power.second;
		cdfs.emplace_back(power.first, sum);
	}
	if (sum == 0.f) {
		THROW_EXCEPTION(InvalidArgumentException, "No valid organization for generation.\n");
	}
	for (auto& cdf : cdfs) {
		cdf.second /= sum;
	}

	for(auto & citizen : citizens) {
		float r = GetRandom(1000) / 1000.f;
		string selectedScheduler;
		for (auto& cdf : cdfs) {
			if (r <= cdf.second) {
				selectedScheduler = cdf.first;
				break;
			}
		}
		shared_ptr<Scheduler> scheduler = schedulerFactory->CreateScheduler(selectedScheduler);
		if (!scheduler) {
			continue;
		}

		citizen->SetScheduler(scheduler);
	}
}

void Populace::Destroy() {

}

void Populace::Tick() {

}

void Populace::Print() {

}

void Populace::ApplyChange(shared_ptr<Change> change, std::unique_ptr<Script>& script) {

}

void Populace::Load(string path) {

}

void Populace::Save(string path) {

}

Time Populace::GetTime() {
	return time;
}

std::vector<std::shared_ptr<Person>>& Populace::GetCitizens() {
	return citizens;
}

std::unique_ptr<JobFactory>& Populace::GetJobFactory() {
	return jobFactory;
}

void Populace::GenerateCitizens(int num) {
	enum LIFE_TYPE {
		LIFE_SINGLE,
		LIFE_MARRY,
		LIFE_BIRTH,
		LIFE_DEAD
	};

	struct Human {
		int idx;
		string name;
		int birth;
		int marry;
		LIFE_TYPE life;
		GENDER_TYPE gender;
		int father;
		int mother;
		int spouse;
		vector<pair<GENDER_TYPE, int>> childs;
	};

	// 分配姓名
	auto name = nameFactory->GetName();
	if (!name) {
		THROW_EXCEPTION(InvalidConfigException, "No enabled name in config.\n");
	}

	// 临时男女数组及年表
	vector<Human> females(1, { -1, "", 0, 0, LIFE_DEAD });
	vector<Human> males(1, { -1, "", 0, 0, LIFE_DEAD });
	vector<int> maleBirths(4096, -1);
	int currentBirth = 0;
	vector<vector<pair<int, LIFE_TYPE>>> chronology(4096);

	// 初始添加100男100女
	int year = 1;
	for (int i = 1; i <= 100; i++) {
		auto n = name->GenerateName(false, true);
		females.push_back({ -1, n, GetRandom(20), -1, LIFE_SINGLE, GENDER_FEMALE, -1, -1, -1, {} });
		chronology[females.back().birth + 20 + GetRandom(15)].push_back(make_pair((int)females.size() - 1, LIFE_MARRY));
		chronology[females.back().birth + 60 + GetRandom(40)].push_back(make_pair((int)females.size() - 1, LIFE_DEAD));
	}
	for (int i = 1; i <= 100; i++) {
		auto n = name->GenerateName(true, false);
		males.push_back({ -1, n, GetRandom(20), -1, LIFE_SINGLE, GENDER_MALE, -1, -1, -1, {} });
	}
	sort(males.begin(), males.end(), [](Human x, Human y) {return x.birth < y.birth; });
	maleBirths[0] = 0;
	for (int i = 1; i <= 100; i++) {
		if (males[i].birth > currentBirth) {
			for (int j = currentBirth + 1; j <= males[i].birth; j++) {
				maleBirths[j] = i;
			}
			currentBirth = males[i].birth;
		}
		chronology[males[i].birth + 60 + GetRandom(40)].push_back(make_pair(-i, LIFE_DEAD));
	}

	// 自动迭代繁殖最多4096年
	while (year < 4096 && females.size() + males.size() < num) {
		for (auto event : chronology[year]) {
			if (event.first >= 0) {
				switch (event.second) {
				case LIFE_MARRY: {
					int lowId = max(0, females[event.first].birth - 10);
					int highId = max(0, females[event.first].birth + 5);
					if (maleBirths[lowId] == maleBirths[highId])break;
					if (maleBirths[highId] == -1)break;
					int selectId = -1;
					for (int i = 0; i < 10; i++) {
						selectId = maleBirths[lowId] + GetRandom(maleBirths[highId] - maleBirths[lowId]);
						if (males[selectId].spouse >= 0) {
							selectId = -1;
							continue;
						}
						else {
							break;
						}
					}
					if (selectId < 0)break;
					females[event.first].spouse = selectId;
					females[event.first].life = LIFE_MARRY;
					females[event.first].marry = year;
					males[selectId].spouse = event.first;
					males[selectId].life = LIFE_MARRY;
					males[selectId].marry = year;
					int childs = ((GetRandom(8) == 0) ? 0 : (1 + GetRandom(6)));
					int interval = 1 + GetRandom(3);
					for (int i = 0; i < childs; i++) {
						if (year + interval - females[event.first].birth > 45)break;
						chronology[year + interval].push_back(make_pair(event.first, LIFE_BIRTH));
						interval += 1 + GetRandom(3);
					}
					break;
				}
				case LIFE_BIRTH: {
					int gender = GetRandom(2);
					auto n = name->GenerateName(name->GetSurname(males[females[event.first].spouse].name),
						gender == GENDER_MALE, gender == GENDER_FEMALE);
					if (gender == GENDER_FEMALE) {
						females[event.first].childs.push_back(make_pair(GENDER_FEMALE, (int)females.size()));
						males[females[event.first].spouse].childs.push_back(make_pair(GENDER_FEMALE, (int)females.size()));
						females.push_back({ -1, n, year, -1, LIFE_SINGLE, GENDER_FEMALE, females[event.first].spouse, event.first, -1, {} });
						if (GetRandom(10) > 0)
							chronology[females.back().birth + 20 + GetRandom(15)].push_back(make_pair((int)females.size() - 1, LIFE_MARRY));
						chronology[females.back().birth + 60 + GetRandom(40)].push_back(make_pair((int)females.size() - 1, LIFE_DEAD));
					}
					else {
						females[event.first].childs.push_back(make_pair(GENDER_MALE, (int)males.size()));
						males[females[event.first].spouse].childs.push_back(make_pair(GENDER_MALE, (int)males.size()));
						males.push_back({ -1, n, year, -1, LIFE_SINGLE, GENDER_MALE, females[event.first].spouse, event.first, -1, {} });
						if (males.back().birth > currentBirth) {
							for (int j = currentBirth + 1; j <= males.back().birth; j++) {
								maleBirths[j] = (int)males.size() - 1;
							}
							currentBirth = males.back().birth;
						}
						chronology[males.back().birth + 60 + GetRandom(40)].push_back(make_pair(-((int)males.size() - 1), LIFE_DEAD));
					}
					break;
				}
				case LIFE_DEAD:
					females[event.first].life = LIFE_DEAD;
					break;
				default:
					break;
				}
			}
			else {
				switch (event.second) {
				case LIFE_DEAD:
					males[-event.first].life = LIFE_DEAD;
					break;
				default:
					break;
				}
			}
		}
		year++;
	}
	time.SetYear(year + 2000);

	// 将活着的男女加入市民列表
	for (int i = 1; i < females.size(); i++) {
		if (females[i].life != LIFE_DEAD && GetRandom(20) > 0) {
			shared_ptr<Person> person = make_shared<Person>();
			person->SetId((int)citizens.size());
			females[i].idx = (int)citizens.size();
			person->SetName(females[i].name);
			person->SetGender(GENDER_FEMALE);
			int month = 1 + GetRandom(12);
			person->SetBirthday({ 2000 + females[i].birth, month, 1 + GetRandom(Time::DaysInMonth(2000 + females[i].birth, month)) });
			citizens.push_back(person);
		}
	}
	for (int i = 1; i < males.size(); i++) {
		if (males[i].life != LIFE_DEAD && GetRandom(20) > 0) {
			shared_ptr<Person> person = make_shared<Person>();
			person->SetId((int)citizens.size());
			males[i].idx = (int)citizens.size();
			person->SetName(males[i].name);
			person->SetGender(GENDER_MALE);
			int month = 1 + GetRandom(12);
			person->SetBirthday({ 2000 + males[i].birth, month, 1 + GetRandom(Time::DaysInMonth(2000 + males[i].birth, month)) });
			citizens.push_back(person);
		}
	}

	// 记录有配偶的市民的结婚日期
	for (int i = 1; i < females.size(); i++) {
		if (females[i].spouse >= 0 && females[i].idx >= 0 && males[females[i].spouse].idx >= 0) {
			int month = GetRandom(12) + 1;
			Time marryday = Time(2000 + females[i].marry, month, 1 + GetRandom(Time::DaysInMonth(2000 + females[i].marry, month)));
			citizens[females[i].idx]->SetMarryday(marryday);
			citizens[males[females[i].spouse].idx]->SetMarryday(marryday);
		}
	}

	// 记录亲属关系
	for (auto female : females) {
		if (female.idx >= 0) {
			shared_ptr<Person> person = citizens[female.idx];
			if (female.mother >= 0 && females[female.mother].idx >= 0)
				person->AddRelative(RELATIVE_MOTHER, citizens[females[female.mother].idx]);
			if (female.father >= 0 && males[female.father].idx >= 0)
				person->AddRelative(RELATIVE_FATHER, citizens[males[female.father].idx]);
			if (female.spouse >= 0 && males[female.spouse].idx >= 0) {
				person->AddRelative(RELATIVE_HUSBAND, citizens[males[female.spouse].idx]);
			}
			for (auto child : female.childs) {
				if (child.first == GENDER_FEMALE && females[child.second].idx >= 0)
					person->AddRelative(RELATIVE_DAUGHTER, citizens[females[child.second].idx]);
				else if (child.first == GENDER_MALE && males[child.second].idx >= 0)
					person->AddRelative(RELATIVE_SON, citizens[males[child.second].idx]);
			}
		}
	}
	for (auto male : males) {
		if (male.idx >= 0) {
			shared_ptr<Person> person = citizens[male.idx];
			if (male.mother >= 0 && females[male.mother].idx >= 0)
				person->AddRelative(RELATIVE_MOTHER, citizens[females[male.mother].idx]);
			if (male.father >= 0 && males[male.father].idx >= 0)
				person->AddRelative(RELATIVE_FATHER, citizens[males[male.father].idx]);
			if (male.spouse >= 0 && females[male.spouse].idx >= 0) {
				person->AddRelative(RELATIVE_WIFE, citizens[females[male.spouse].idx]);
			}
			for (auto child : male.childs) {
				if (child.first == GENDER_FEMALE && females[child.second].idx >= 0)
					person->AddRelative(RELATIVE_DAUGHTER, citizens[females[child.second].idx]);
				else if (child.first == GENDER_MALE && males[child.second].idx >= 0)
					person->AddRelative(RELATIVE_SON, citizens[males[child.second].idx]);
			}
		}
	}

	debugf("Generate %d citizens.\n", citizens.size());
}

void Populace::GeneratePhones() {
	for (auto citizen : citizens) {
		int number;
		do {
			number = (int)pow(10, 9);
			for (int i = 0; i < 9; i++) {
				number += GetRandom(10) * (int)pow(10, i);
			}
		} while (phoneRoll.find(number) != phoneRoll.end() && phoneRoll[number] != citizen);

		phoneRoll[number] = citizen;
		citizen->SetPhone(number);
	}

	debugf("Generate phones.\n");
}

void Populace::GeneratePhysics() {
	for (auto citizen : citizens) {
		float r = GetRandom(1000) / 1000.f;
		r = pow(r, 4.f);
		if (GetRandom(2))r = -r;

		int age = citizen->GetAge(time);
		if (age > 15) {
			if (citizen->GetGender() == GENDER_MALE) {
				citizen->SetHeight(1.75f + r * 0.2f);
			}
			else {
				citizen->SetHeight(1.65f + r * 0.15f);
			}
		}
		else {
			if (citizen->GetGender() == GENDER_MALE) {
				citizen->SetHeight((1.75f + r * 0.2f) * (0.3f + age / 15.f * 0.7f));
			}
			else {
				citizen->SetHeight((1.65f + r * 0.15f) * (0.3f + age / 15.f * 0.7f));
			}
		}
	}

	debugf("Generate height and weight.\n");
}

void Populace::GenerateFinance() {
	for (auto citizen : citizens) {
		float r = GetRandom(1000) / 1000.f;
		r = pow(r, 12.f);

		citizen->SetDeposit((int)(1e8f * r));
	}

	debugf("Generate deposit.\n");
}

void Populace::GenerateEducations() {
	enum EducationLevel {
		EDUCATION_PRIMARY,
		EDUCATION_JUNIOR,
		EDUCATION_SENIOR,
		EDUCATION_COLLEGE,
		EDUCATION_POST,
		EDUCATION_END
	};

	struct SchoolClass {
		string schoolName;
		EducationLevel level;
		int startYear;
		int grade;
		vector<int> students;
		int teacher = -1;
	};
	vector<SchoolClass> levelClasses[EDUCATION_END];

	// 从120年前开始模拟
	mt19937 generator(random_device{}());
	vector<int> levelPotentials[EDUCATION_END];
	for (int year = time.GetYear() - 120; year <= time.GetYear(); year++) {
		// 班级变动
		for (int level = EDUCATION_PRIMARY; level <= EDUCATION_POST; level++) {
			for (auto& cls : levelClasses[level]) {
				Time begin(year - 1, 9, 1);
				Time end(year, 6, 30);

				for (auto student : cls.students) {
					EducationExperience eduExp;
					eduExp.SetSchool(cls.schoolName);
					eduExp.SetTime(begin, end);
					citizens[student]->AddEducationExperience(eduExp);
				}
			}

			for (auto& cls : levelClasses[level]) {
				for (auto studentIt = cls.students.begin(); studentIt != cls.students.end(); ) {
					int fate = GetRandom(100);

					if (fate > 95) { // 转学
						vector<SchoolClass*> targetClasses;
						for (auto& target : levelClasses[level]) {
							if (&target != &cls && target.grade == cls.grade &&
								target.startYear == cls.startYear) {
								targetClasses.push_back(&target);
							}
						}
						if (!targetClasses.empty()) {
							SchoolClass* targetClass = targetClasses[GetRandom((int)targetClasses.size())];
							targetClass->students.push_back(*studentIt);
							studentIt = cls.students.erase(studentIt);
						}
						else {
							++studentIt;
						}
					}
					else if (fate > 92) { // 留级
						vector<SchoolClass*> targetClasses;
						for (auto& target : levelClasses[level]) {
							if (&target != &cls && target.grade == cls.grade - 1 &&
								target.schoolName == cls.schoolName) {
								targetClasses.push_back(&target);
							}
						}
						if (!targetClasses.empty()) {
							SchoolClass* targetClass = targetClasses[GetRandom((int)targetClasses.size())];
							targetClass->students.push_back(*studentIt);
							studentIt = cls.students.erase(studentIt);
						}
						else {
							++studentIt;
						}
					}
					else if (fate > 90) { // 跳级
						bool valid = false;
						if (level == EDUCATION_PRIMARY && cls.grade < 6) {
							valid = true;
						}
						if (level == EDUCATION_JUNIOR && cls.grade < 3) {
							valid = true;
						}
						if (level == EDUCATION_SENIOR && cls.grade < 3) {
							valid = true;
						}
						if (level == EDUCATION_COLLEGE && cls.grade < 4) {
							valid = true;
						}

						if (valid) {
							vector<SchoolClass*> targetClasses;
							for (auto& target : levelClasses[level]) {
								if (target.grade == cls.grade + 1 &&
									target.schoolName == cls.schoolName) {
									targetClasses.push_back(&target);
								}
							}
							if (!targetClasses.empty()) {
								SchoolClass* targetClass = targetClasses[GetRandom((int)targetClasses.size())];
								targetClass->students.push_back(*studentIt);
								studentIt = cls.students.erase(studentIt);
							}
							else {
								++studentIt;
							}
						}
						else {
							++studentIt;
						}
					}
					else {
						++studentIt;
					}
				}

				cls.grade++;
				if (level < EDUCATION_POST) {
					int maxGrade;
					float continueRatio;
					float stayRatio;
					if (level == EDUCATION_PRIMARY) {
						maxGrade = 6;
						continueRatio = 0.98f;
						stayRatio = 0.99f;
					}
					if (level == EDUCATION_JUNIOR) {
						maxGrade = 3;
						continueRatio = 0.9f;
						stayRatio = 0.98f;
					}
					if (level == EDUCATION_SENIOR) {
						maxGrade = 3;
						continueRatio = 0.7f;
						stayRatio = 0.96f;
					}
					if (level == EDUCATION_COLLEGE) {
						maxGrade = 4;
						continueRatio = 0.3f;
						stayRatio = 0.92f;
					}

					if (cls.grade > maxGrade) {
						cls.students.resize((int)(cls.students.size() * continueRatio));
						levelPotentials[level + 1].insert(levelPotentials[level + 1].end(), cls.students.begin(), cls.students.end());
						cls.students.clear();
					}
					else {
						float ratio = (100 - GetRandom((int)((1.0f - stayRatio) * 100))) / 100.0f;
						size_t newSize = (int)(cls.students.size() * ratio);
						for (auto studentIt = cls.students.begin() + newSize; studentIt != cls.students.end(); ++studentIt) {
							if (citizens[*studentIt]->GetEducationExperiences().size() > 0)
								citizens[*studentIt]->GetEducationExperiences().back().SetGraduate(false);
						}
						cls.students.resize(newSize);
					}
				}
				else {
					for (auto studentIt = cls.students.begin(); studentIt != cls.students.end(); ) {
						if (cls.grade > 2 && GetRandom(7 - cls.grade) == 0) {
							studentIt = cls.students.erase(studentIt);
						}
						else {
							++studentIt;
						}
					}
				}
			}

			auto& classes = levelClasses[level];
			classes.erase(
				remove_if(classes.begin(), classes.end(),
					[](const SchoolClass& c) { return c.students.empty(); }),
				classes.end());
		}

		// 适龄小学生
		for (int i = 0; i < citizens.size(); i++) {
			int birthYear = citizens[i]->GetBirthday().GetYear();
			if (birthYear < year - 5) {
				if (GetRandom(9 + birthYear - year) == 0 && citizens[i]->GetEducationExperiences().size() == 0)
					levelPotentials[EDUCATION_PRIMARY].push_back(i);
			}
		}

		// 小学入学
		if (!levelPotentials[EDUCATION_PRIMARY].empty()) {
			int classCount = max(1, (int)levelPotentials[EDUCATION_PRIMARY].size() / (20 + GetRandom(20)));
			if (classCount == 0)classCount = 1;

			int schoolCount = max(1, classCount / 5);
			vector<string> schoolNames;
			for (int i = 0; i < schoolCount; i++) {
				schoolNames.push_back("第" + to_string(i + 1) + "小学");
			}
			shuffle(levelPotentials[EDUCATION_PRIMARY].begin(), levelPotentials[EDUCATION_PRIMARY].end(), generator);
			int studentsPerClass = (int)levelPotentials[EDUCATION_PRIMARY].size() / classCount;

			for (int i = 0; i < classCount; i++) {
				SchoolClass newClass;
				newClass.schoolName = schoolNames[i % schoolNames.size()];
				newClass.startYear = year;
				newClass.grade = 1;
				newClass.level = EDUCATION_PRIMARY;

				int startIdx = i * studentsPerClass;
				int endIdx = (i == classCount - 1) ? (int)levelPotentials[EDUCATION_PRIMARY].size() : (i + 1) * studentsPerClass;
				for (int j = startIdx; j < endIdx; j++) {
					newClass.students.push_back(levelPotentials[EDUCATION_PRIMARY][j]);
				}

				levelClasses[EDUCATION_PRIMARY].push_back(newClass);
			}
			levelPotentials[EDUCATION_PRIMARY].clear();
		}

		// 初中入学
		if (!levelPotentials[EDUCATION_JUNIOR].empty()) {
			int classCount = max(1, (int)levelPotentials[EDUCATION_JUNIOR].size() / (20 + GetRandom(20)));
			if (classCount == 0)classCount = 1;

			int schoolCount = max(1, classCount / 4);
			vector<string> schoolNames;
			for (int i = 0; i < schoolCount; i++) {
				schoolNames.push_back("第" + to_string(i + 1) + "初中");
			}

			shuffle(levelPotentials[EDUCATION_JUNIOR].begin(), levelPotentials[EDUCATION_JUNIOR].end(), generator);
			int studentsPerClass = (int)levelPotentials[EDUCATION_JUNIOR].size() / classCount;

			for (int i = 0; i < classCount; i++) {
				SchoolClass newClass;
				newClass.schoolName = schoolNames[i % schoolNames.size()];
				newClass.startYear = year;
				newClass.grade = 1;
				newClass.level = EDUCATION_JUNIOR;

				int startIdx = i * studentsPerClass;
				int endIdx = (i == classCount - 1) ? (int)levelPotentials[EDUCATION_JUNIOR].size() : (i + 1) * studentsPerClass;
				for (int j = startIdx; j < endIdx; j++) {
					newClass.students.push_back(levelPotentials[EDUCATION_JUNIOR][j]);
				}

				levelClasses[EDUCATION_JUNIOR].push_back(newClass);
			}
			levelPotentials[EDUCATION_JUNIOR].clear();
		}

		// 高中入学
		if (!levelPotentials[EDUCATION_SENIOR].empty()) {
			int classCount = max(1, (int)levelPotentials[EDUCATION_SENIOR].size() / (30 + GetRandom(20)));
			if (classCount == 0)classCount = 1;

			int schoolCount = max(1, classCount / 4);
			vector<string> schoolNames;
			for (int i = 0; i < schoolCount; i++) {
				schoolNames.push_back("第" + to_string(i + 1) + "高中");
			}

			shuffle(levelPotentials[EDUCATION_SENIOR].begin(), levelPotentials[EDUCATION_SENIOR].end(), generator);
			int studentsPerClass = (int)levelPotentials[EDUCATION_SENIOR].size() / classCount;

			for (int i = 0; i < classCount; i++) {
				SchoolClass newClass;
				newClass.schoolName = schoolNames[i % schoolNames.size()];
				newClass.startYear = year;
				newClass.grade = 1;
				newClass.level = EDUCATION_SENIOR;

				int startIdx = i * studentsPerClass;
				int endIdx = (i == classCount - 1) ? (int)levelPotentials[EDUCATION_SENIOR].size() : (i + 1) * studentsPerClass;
				for (int j = startIdx; j < endIdx; j++) {
					newClass.students.push_back(levelPotentials[EDUCATION_SENIOR][j]);
				}

				levelClasses[EDUCATION_SENIOR].push_back(newClass);
			}
			levelPotentials[EDUCATION_SENIOR].clear();
		}

		// 大学入学
		if (!levelPotentials[EDUCATION_COLLEGE].empty()) {
			int majorCount = 5 + GetRandom(5);
			vector<string> schoolNames;
			for (int i = 0; i < majorCount; i++) {
				schoolNames.push_back("第" + to_string(i + 1) + "大学");
			}

			shuffle(levelPotentials[EDUCATION_COLLEGE].begin(), levelPotentials[EDUCATION_COLLEGE].end(), generator);
			int studentsPerMajor = (int)levelPotentials[EDUCATION_COLLEGE].size() / majorCount;

			for (int i = 0; i < majorCount; i++) {
				SchoolClass newClass;
				newClass.schoolName = schoolNames[i];
				newClass.startYear = year;
				newClass.grade = 1;
				newClass.level = EDUCATION_COLLEGE;

				int startIdx = i * studentsPerMajor;
				int endIdx = (i == majorCount - 1) ? (int)levelPotentials[EDUCATION_COLLEGE].size() : (i + 1) * studentsPerMajor;
				for (int j = startIdx; j < endIdx; j++) {
					newClass.students.push_back(levelPotentials[EDUCATION_COLLEGE][j]);
				}

				levelClasses[EDUCATION_COLLEGE].push_back(newClass);
			}
			levelPotentials[EDUCATION_COLLEGE].clear();
		}

		// 研究生入学
		if (!levelPotentials[EDUCATION_POST].empty()) {
			int majorCount = 3 + GetRandom(3);
			vector<string> schoolNames;
			for (int i = 0; i < majorCount; i++) {
				schoolNames.push_back("第" + to_string(i + 1) + "研究院");
			}

			shuffle(levelPotentials[EDUCATION_POST].begin(), levelPotentials[EDUCATION_POST].end(), generator);
			int studentsPerMajor = (int)levelPotentials[EDUCATION_POST].size() / majorCount;

			for (int i = 0; i < majorCount; i++) {
				SchoolClass newClass;
				newClass.schoolName = schoolNames[i];
				newClass.startYear = year;
				newClass.grade = 1;
				newClass.level = EDUCATION_POST;

				int startIdx = i * studentsPerMajor;
				int endIdx = (i == majorCount - 1) ? (int)levelPotentials[EDUCATION_POST].size() : (i + 1) * studentsPerMajor;
				for (int j = startIdx; j < endIdx; j++) {
					newClass.students.push_back(levelPotentials[EDUCATION_POST][j]);
				}

				levelClasses[EDUCATION_POST].push_back(newClass);
			}
			levelPotentials[EDUCATION_POST].clear();
		}
	}
	for (auto citizen : citizens) {
		citizen->ExperienceComposition();
	}

	debugf("Generate educations.\n");
}

void Populace::GenerateEmotions() {
	for (auto citizen : citizens) {
		// 计算本人情感经历范围
		int birthYear = citizen->GetBirthday().GetYear();
		int currentAge = time.GetYear() - birthYear;
		if (currentAge < 16) continue;

		Time startBound = citizen->GetBirthday() + Time(16, 1, 1);
		Time endBound;
		shared_ptr<Person> spouse = citizen->GetSpouse();
		if (spouse) {
			endBound = citizen->GetMarryday();
		}
		else {
			endBound = time;
		}
		if (startBound >= endBound) continue;

		int maxRelationships = min(10, (endBound - startBound).GetYear() / 3 + 1);
		int relationshipCount = GetRandom(maxRelationships + 1);
		relationshipCount = max(relationshipCount - (int)citizen->GetEmotionExperiences().size(), 0);

		// 随机生成指定段数的经历
		vector<EmotionExperience> newEmotions;
		vector<pair<Time, Time>> allocatedPeriods;
		for (int i = 0; i < relationshipCount; i++) {
			Time startTime, endTime;
			bool validPeriod = false;
			int attempts = 0;

			// 首先生成一段符合本人时间段的经历
			while (!validPeriod && attempts < 100) {
				attempts++;

				startTime = GetRandom(startBound, endBound);

				int minDuration = 1;
				int maxDuration = Time::DaysBetween(startTime, endBound) + 1;
				float r = GetRandom(1000) / 1000.0f;
				int durationDays = minDuration + (int)((maxDuration - minDuration + 1) * pow(r, 4.f));
				endTime = startTime;
				endTime.AddDays(durationDays - 1);
				if (endTime > endBound) endTime = endBound;

				validPeriod = true;
				for (const auto& period : allocatedPeriods) {
					if (!(endTime < period.first || startTime > period.second)) {
						validPeriod = false;
						break;
					}
				}

				if (validPeriod) {
					for (const auto& exp : citizen->GetEmotionExperiences()) {
						if (!(endTime < exp.GetBeginTime() || startTime > exp.GetEndTime())) {
							validPeriod = false;
							break;
						}
					}
				}
			}
			if (!validPeriod) continue;

			// 随机寻找伴侣并判断该经历是否符合其时间段
			shared_ptr<Person> partner = nullptr;
			int candidateAttempts = 0;
			while (!partner && candidateAttempts < 100) {
				candidateAttempts++;

				int idx = GetRandom((int)citizens.size());
				shared_ptr<Person> candidate = citizens[idx];
				if (candidate->GetGender() == citizen->GetGender())continue;
				if (candidate == citizen) continue;

				bool isCloseRelative = false;
				if (candidate == citizen->GetSpouse())isCloseRelative = true;
				if (citizen->GetFather()) {
					for (auto relative : citizen->GetFather()->GetChilds()) {
						if (candidate == relative) {
							isCloseRelative = true;
							break;
						}
					}
				}
				if (citizen->GetMother()) {
					for (auto relative : citizen->GetMother()->GetChilds()) {
						if (candidate == relative) {
							isCloseRelative = true;
							break;
						}
					}
				}
				if (isCloseRelative) continue;

				int candidateBirthYear = candidate->GetBirthday().GetYear();
				int candidateAge = startTime.GetYear() - candidateBirthYear;
				int ageDiff = abs(birthYear - candidateBirthYear);
				if (candidateAge < 16 || ageDiff > 10) continue;

				bool timeAvailable = true;
				for (const auto& exp : candidate->GetEmotionExperiences()) {
					if (!(endTime < exp.GetBeginTime() || startTime > exp.GetEndTime())) {
						timeAvailable = false;
						break;
					}
				}
				if (!timeAvailable) continue;

				shared_ptr<Person> candidateSpouse = candidate->GetSpouse();
				if (candidateSpouse) {
					Time marryTime = candidate->GetMarryday();
					if (marryTime < endTime) {
						continue;
					}
				}
				partner = candidate;
			}
			if (!partner) continue;
			if (startTime > endTime)continue;

			// 写入经历
			EmotionExperience emotionExp;
			emotionExp.SetPerson(partner);
			emotionExp.SetTime(startTime, endTime);
			newEmotions.push_back(emotionExp);
			allocatedPeriods.emplace_back(startTime, endTime);

			EmotionExperience partnerExp;
			partnerExp.SetPerson(citizen);
			partnerExp.SetTime(startTime, endTime);
			partner->AddEmotionExperience(partnerExp);
		}

		// 将临时经历全部写入本人经历
		for (const auto& exp : newEmotions) {
			citizen->AddEmotionExperience(exp);
		}

		// 四成未婚市民存在正在进行的恋爱
		if (!spouse && GetRandom(100) < 40) {
			shared_ptr<Person> currentPartner = nullptr;
			int candidateAttempts = 0;

			Time marrigeBegin = citizen->GetBirthday() + Time(16, 1, 1);
			for (auto experience : citizen->GetEmotionExperiences()) {
				if (experience.GetEndTime() > marrigeBegin)
					marrigeBegin = experience.GetEndTime();
			}
			Time marrigeTime = GetRandom(marrigeBegin, time);
			while (!currentPartner && candidateAttempts < 100) {
				candidateAttempts++;

				int idx = GetRandom((int)citizens.size());
				shared_ptr<Person> candidate = citizens[idx];
				if (candidate->GetGender() == citizen->GetGender())continue;
				if (candidate == citizen || candidate->GetSpouse()) continue;

				bool isCloseRelative = false;
				if (candidate == citizen->GetSpouse())isCloseRelative = true;
				if (citizen->GetFather()) {
					for (auto relative : citizen->GetFather()->GetChilds()) {
						if (candidate == relative) {
							isCloseRelative = true;
							break;
						}
					}
				}
				if (citizen->GetMother()) {
					for (auto relative : citizen->GetMother()->GetChilds()) {
						if (candidate == relative) {
							isCloseRelative = true;
							break;
						}
					}
				}
				if (isCloseRelative) continue;

				int candidateBirthYear = candidate->GetBirthday().GetYear();
				int candidateAge = time.GetYear() - candidateBirthYear;
				int ageDiff = abs(currentAge - candidateAge);
				if (ageDiff > 10) continue;

				bool timeAvailable = true;
				for (const auto& exp : candidate->GetEmotionExperiences()) {
					if (exp.GetEndTime() >= marrigeTime) {
						timeAvailable = false;
						break;
					}
				}
				if (!timeAvailable) continue;

				currentPartner = candidate;
			}

			if (currentPartner) {
				EmotionExperience currentExp;
				currentExp.SetPerson(currentPartner);
				currentExp.SetTime(marrigeTime, time);

				citizen->AddEmotionExperience(currentExp);

				EmotionExperience partnerExp;
				partnerExp.SetPerson(citizen);
				partnerExp.SetTime(marrigeTime, time);
				currentPartner->AddEmotionExperience(partnerExp);
			}
		}
	}

	debugf("Generate emotions.\n");
}

void Populace::GenerateJobs() {


	debugf("Generate jobs.\n");
}


// ===== .\Forever\populace.h =====

﻿#pragma once

#include "utility.h"
#include "asset.h"
#include "job.h"
#include "name.h"
#include "person.h"
#include "scheduler.h"
#include "room.h"
#include "change.h"
#include "script.h"

#include <windows.h>


class Populace {
public:
	Populace();
	~Populace();

	// 读取Mods
	void InitAssets();
	void InitJobs();
	void InitNames();
	void InitSchedulers();

	// 读取配置文件
	void ReadConfigs(std::string path) const;

	// 初始化市民
	void Init(int accomodation);

	// 分配调度
	void Schedule();

	// 释放空间
	void Destroy();

	// 时钟前进
	void Tick();

	// 输出当前地图
	void Print();

	// 应用变更
	void ApplyChange(std::shared_ptr<Change> change, std::unique_ptr<Script>& script);

	// 保存/加载人口
	void Load(std::string path);
	void Save(std::string path);

	// 获取当前时间
	Time GetTime();

	// 获取全部市民
	std::vector<std::shared_ptr<Person>>& GetCitizens();

	// 获取附近市民
	std::vector<std::shared_ptr<Person>> GetPasser(int x, int y);
	std::vector<std::shared_ptr<Person>> GetPasser(std::shared_ptr<Room>);
	std::vector<std::shared_ptr<Person>> GetComer(int x, int y);
	std::vector<std::shared_ptr<Person>> GetComer(std::shared_ptr<Room>);

	// 获取Job工厂
	std::unique_ptr<JobFactory>& GetJobFactory();

private:
	// Mod管理
	std::vector<HMODULE> modHandles;
	std::unique_ptr<AssetFactory> assetFactory;
	std::unique_ptr<JobFactory> jobFactory;
	std::unique_ptr<NameFactory> nameFactory;
	std::unique_ptr<SchedulerFactory> schedulerFactory;

	// 游戏内时间
	Time time;

	// 市民管理
	std::vector<std::shared_ptr<Person>> citizens;
	std::unordered_map<int, std::shared_ptr<Person>> phoneRoll;

	// 生成市民
	void GenerateCitizens(int num);

	// 生成基础属性
	void GeneratePhones();
	void GeneratePhysics();
	void GenerateFinance();

	// 生成经历
	void GenerateEducations();
	void GenerateEmotions();
	void GenerateJobs();
};



// ===== .\Forever\roadnet.cpp =====

﻿#include "roadnet.h"


using namespace std;



// ===== .\Forever\roadnet.h =====

﻿#pragma once

#include "roadnet_base.h"


// 子类注册函数
typedef void (*RegisterModRoadnetsFunc)(RoadnetFactory* factory);

// 主程序检测子类
class TestRoadnet : public Roadnet {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试路网"; }

    virtual void DistributeRoadnet(int width, int height,
        std::function<std::string(int, int)> get) override {
        Node n1 = Node(width / 2.f + 32.f, height / 2.f + 32.f);
        Node n2 = Node(width / 2.f - 32.f, height / 2.f + 32.f);
        Node n3 = Node(width / 2.f - 32.f, height / 2.f - 32.f);
        Node n4 = Node(width / 2.f + 32.f, height / 2.f - 32.f);
        nodes.push_back(n1);
        nodes.push_back(n2);
        nodes.push_back(n3);
        nodes.push_back(n4);
        connections.push_back(Connection(n1, n2));
        connections.push_back(Connection(n2, n3));
        connections.push_back(Connection(n3, n4));
        connections.push_back(Connection(n4, n1));
        plots.push_back(std::make_shared<Plot>(n1, n2, n3, n4));
        plots.back()->SetArea(AREA_GREEN);
    }
};


// ===== .\Forever\room.cpp =====

﻿#include "room.h"


using namespace std;



// ===== .\Forever\room.h =====

﻿#pragma once

#include "room_base.h"


// 子类注册函数
typedef void (*RegisterModRoomsFunc)(RoomFactory* factory);

// 主程序检测子类
class TestRoom : public Room {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试房间"; }

    virtual bool IsResidential() const override { return true; };
    virtual bool IsWorkspace() const override { return false; }
    virtual int GetLivingCapacity() const override { return 2; }
    virtual int GetPersonnelCapacity() const override { return 0; }
};


// ===== .\Forever\scheduler.cpp =====

﻿#include "scheduler.h"


using namespace std;

TestScheduler::TestScheduler() {

}

TestScheduler::~TestScheduler() {

}


// ===== .\Forever\scheduler.h =====

﻿#pragma once

#include "scheduler_base.h"
#include "zone_base.h"


// 子类注册函数
typedef void (*RegisterModSchedulersFunc)(SchedulerFactory* factory);

// 主程序检测子类
class TestScheduler : public Scheduler {
public:
    TestScheduler();
    ~TestScheduler();

    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试调度"; }

    static float GetPower() {
        return 1.0f;
    }

private:

};


// ===== .\Forever\script.cpp =====

﻿#include "script.h"
#include "change.h"
#include "json.h"
#include "error.h"

#include <iostream>
#include <string>
#include <fstream>
#include <filesystem>
#include <unordered_map>


using namespace std;

Script::Script() {
	eventFactory.reset(new EventFactory());
	changeFactory.reset(new ChangeFactory());
}

Script::~Script() {

}

void Script::InitEvents() {
	eventFactory->RegisterEvent(GameStartEvent::GetId(), []() { return make_unique<GameStartEvent>(); });
	eventFactory->RegisterEvent(OptionDialogEvent::GetId(), []() { return make_unique<OptionDialogEvent>(); });

	HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
	if (modHandle) {
		modHandles.push_back(modHandle);
		debugf("Mod dll loaded successfully.\n");

		RegisterModEventsFunc registerFunc = (RegisterModEventsFunc)GetProcAddress(modHandle, "RegisterModEvents");
		if (registerFunc) {
			registerFunc(eventFactory.get());
		}
		else {
			debugf("Incorrect dll content.");
		}
	}
	else {
		debugf("Failed to load mod.dll.");
	}

#ifdef MOD_TEST
	auto eventList = { "game_start", "option_dialog", "mod"};
	for (const auto& eventId : eventList) {
		if (eventFactory->CheckRegistered(eventId)) {
			auto event = eventFactory->CreateEvent(eventId);
			debugf(("Created event: " + event->GetName() + " (ID: " + eventId + ")\n").data());
		}
		else {
			debugf("Event not registered: %s\n", eventId);
		}
	}
#endif // MOD_TEST
}

void Script::InitChanges() {
	changeFactory->RegisterChange(SetValueChange::GetId(), []() { return make_unique<SetValueChange>(); });
	changeFactory->RegisterChange(RemoveValueChange::GetId(), []() { return make_unique<RemoveValueChange>(); });

	HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
	if (modHandle) {
		modHandles.push_back(modHandle);
		debugf("Mod dll loaded successfully.\n");

		RegisterModChangesFunc registerFunc = (RegisterModChangesFunc)GetProcAddress(modHandle, "RegisterModChanges");
		if (registerFunc) {
			registerFunc(changeFactory.get());
		}
		else {
			debugf("Incorrect dll content.");
		}
	}
	else {
		debugf("Failed to load mod.dll.");
	}

#ifdef MOD_TEST
	auto changeList = { "set_value", "remove_value", "mod" };
	for (const auto& changeId : changeList) {
		if (changeFactory->CheckRegistered(changeId)) {
			auto change = changeFactory->CreateChange(changeId);
			debugf(("Created change: " + change->GetName() + " (ID: " + changeId + ")\n").data());
		}
		else {
			debugf("Change not registered: %s\n", changeId);
		}
	}
#endif // MOD_TEST
}

void Script::Print() {
	cout << "活动里程碑数量 " << actives.size() << endl;
	for (auto active : actives) {
		cout << active->content.GetName() << ": " << active->content.GetGoal() << endl;
	}

	cout << "全局变量数量 " << variables.size() << endl;
	for (auto value : variables) {
		cout << value.first << ": " << ToString(value.second) << endl;
	}
}

void Script::ReadScript(string path) {
    if (!filesystem::exists(path)) {
        THROW_EXCEPTION(IOException, "Path does not exist: " + path + ".\n");
    }

	Json::Reader reader;
	Json::Value root;

	ifstream fin(path);
	if (!fin.is_open()) {
        THROW_EXCEPTION(IOException, "Failed to open file: " + path + ".\n");
	}
	if (reader.parse(fin, root)) {
		unordered_map<string, int> hash;
		hash["game_finish"] = -1;
		hash["game_fail"] = -2;

		for (auto milestone : root) {
			Milestone content(
				milestone["milestone"].asString(),
				BuildEvent(milestone["trigger"]),
				milestone["visible"].asBool(),
				BuildCondition(milestone["drop"].asString()),
				milestone["description"].asString(),
				milestone["goal"].asString(),
				BuildDialogs(milestone["dialogs"]),
				BuildChanges(milestone["changes"])
			);
			hash.insert(make_pair(milestone["milestone"].asString(), (int)milestones.size()));
			milestones.push_back(MilestoneNode(content));
		}
		for (int i = 0; i < milestones.size(); i++) {
			for (auto subsequence : root[i]["subsequences"]) {
                if (hash.find(subsequence.asString()) == hash.end())continue;
				if (hash[subsequence.asString()] < 0)continue;

				milestones[i].subsequents.push_back(&milestones[hash[subsequence.asString()]]);
				milestones[hash[subsequence.asString()]].premise++;
			}
		}
		for (auto &milestone : milestones) {
			if (milestone.premise == 0) {
				actives.push_back(&milestone);
			}
		}
	}
	else{
        THROW_EXCEPTION(JsonFormatException, "Json syntax error: " + reader.getFormattedErrorMessages() + ".\n");
	}
	fin.close();
}

void Script::ApplyChange(shared_ptr<Change> change) {
	auto type = change->GetType();
	if(type == "set_value") {
		auto obj = dynamic_pointer_cast<SetValueChange>(change);
		if (obj->GetVariable().substr(0, 7) == "system.") {
			return;
		}
		Condition condition;
		condition.ParseCondition(obj->GetValue());
		variables[obj->GetVariable()] = condition.EvaluateValue([this](string name) -> ValueType {
			return this->GetValue(name);
			});
	}
	else if(type == "remove_value") {
		auto obj = dynamic_pointer_cast<RemoveValueChange>(change);
		if (obj->GetVariable().substr(0, 7) == "system.") {
			return;
		}
		variables.erase(obj->GetVariable());
	}
}

void Script::SaveStory(string path) {

}

void Script::LoadStory(string path) {

}

bool Script::JudgeCondition(Condition& condition) {
	return condition.EvaluateBool([this](string name) -> ValueType {
		return this->GetValue(name);
		});
}

pair<vector<Dialog>, vector<shared_ptr<Change>>> Script::MatchEvent(shared_ptr<Event> event) {
	pair<vector<Dialog>, vector<shared_ptr<Change>>> results;
	results.first.clear();
	results.second.clear();

	vector<MilestoneNode*> tmps;
    for (auto it = actives.begin(); it != actives.end(); ) {
        if (!JudgeCondition((*it)->content.GetTrigger()->GetCondition())) {
            ++it;
            continue;
        }
        if ((*it)->content.MatchTrigger(event)) {
            auto subsequents = (*it)->subsequents;
            for (auto subsequent : subsequents) {
                subsequent->premise--;
                if (subsequent->premise <= 0) {
                    tmps.push_back(subsequent);
                }
            }

            auto dialogs = (*it)->content.GetDialogs();
            results.first.insert(results.first.end(), dialogs.begin(), dialogs.end());
            auto changes = (*it)->content.GetChanges();
            results.second.insert(results.second.end(), changes.begin(), changes.end());

			if ((*it)->content.DropSelf([this](string name) -> ValueType {
				return this->GetValue(name);
				})) {
				it = actives.erase(it);
			}
			else {
				it++;
			}
        }
        else {
            ++it;
        }
    }
	actives.insert(actives.end(), tmps.begin(), tmps.end());

	return results;
}

string Script::ReplaceContent(const string& content) {
	std::string result;
	size_t pos = 0;
	size_t lastPos = 0;

	while ((pos = content.find("$$", lastPos)) != std::string::npos) {
		result.append(content, lastPos, pos - lastPos);

		size_t varStart = pos + 2;
		size_t varEnd = varStart;
		while (varEnd < content.length() && IsIdentifierChar(content[varEnd])) {
			varEnd++;
		}

		std::string varName = content.substr(varStart, varEnd - varStart);
		if (!varName.empty()) {
			auto it = variables.find(varName);
			if (it != variables.end()) {
				result += ToString(it->second);
			}
			else {
				result.append(content, pos, varEnd - pos);
			}
		}
		else {
			result.append(content, pos, 2);
		}
		lastPos = varEnd;
	}
	result.append(content, lastPos, content.length() - lastPos);

	return result;
}

shared_ptr<Event> Script::BuildEvent(Json::Value root) {
    shared_ptr<Event> event = nullptr;

    string type = root["type"].asString();

	if (type == "game_start") {
		event = make_shared<GameStartEvent>();
	}
    else if (type == "option_dialog") {
        event = make_shared<OptionDialogEvent>(root["target"].asString(), root["option"].asString());
    }
	else if (eventFactory->CheckRegistered(type)) {
		event = eventFactory->CreateEvent(type);
	}

    if (!event) {
        THROW_EXCEPTION(InvalidArgumentException, "Invalid event type: " + type + ".\n");
    }
    event->SetCondition(BuildCondition(root["condition"]));

    return event;
}

vector<Dialog> Script::BuildDialogs(Json::Value root) {
    vector<Dialog> dialogs;

    for (auto obj : root) {
        Dialog dialog;

        dialog.SetCondition(BuildCondition(obj["condition"]));

        for (auto speak : obj["list"]) {
            dialog.AddDialog(speak["speaker"].asString(), speak["content"].asString());
        }

        dialogs.push_back(dialog);
    }

    return dialogs;
}

vector<shared_ptr<Change>> Script::BuildChanges(Json::Value root) {
    vector<shared_ptr<Change>> changes;

    for (auto obj : root) {
        string type = obj["type"].asString();
        shared_ptr<Change> change = nullptr;

        if (type == "set_value") {
            change = make_shared<SetValueChange>(obj["variable"].asString(), obj["value"].asString());
        }
        else if (type == "remove_value") {
            change = make_shared<RemoveValueChange>(obj["variable"].asString());
        }
		else if (changeFactory->CheckRegistered(type)) {
			change = changeFactory->CreateChange(type);
		}

        if (!change) {
            THROW_EXCEPTION(InvalidArgumentException, "Invalid change type: " + type + ".\n");
        }

		change->SetCondition(BuildCondition(obj["condition"]));
        changes.push_back(change);
    }

    return changes;
}

Condition Script::BuildCondition(Json::Value root) {
	Condition condition;

	condition.ParseCondition(root.asString());

	return condition;
}

void Script::InitVariables() {
    variables["system.health_status"] = "healthy";
}

ValueType Script::GetValue(const std::string& name) {
	auto it = variables.find(name);
	if (it != variables.end()) {
		return it->second;
	}
	return 0; // 默认返回0
}

void Script::SetValue(const std::string& name, ValueType value) {
	variables[name] = value;
}




// ===== .\Forever\script.h =====

﻿#pragma once

#include "utility.h"
#include "json.h"
#include "dialog.h"
#include "event.h"
#include "change.h"
#include "milestone.h"
#include "condition.h"

#include <vector>
#include <string>
#include <set>
#include <unordered_map>


class Script {
public:
	Script();
	~Script();

	// 读取Mods
	void InitEvents();
	void InitChanges();

	// 输出当前剧本信息
	void Print();

	// 读取剧本
	void ReadScript(std::string path);

	// 应用变更
	void ApplyChange(std::shared_ptr<Change> change);

	// 保存/读取存档
	void SaveStory(std::string path);
	void LoadStory(std::string path);

	// 判断条件
	bool JudgeCondition(Condition &condition);

	// 匹配事件
	std::pair<std::vector<Dialog>, std::vector<std::shared_ptr<Change>>> MatchEvent(std::shared_ptr<Event> event);

	// 替换文本变量
	std::string ReplaceContent(const std::string& content);

private:
	// Mod管理
	std::vector<HMODULE> modHandles;
	std::unique_ptr<EventFactory> eventFactory;
	std::unique_ptr<ChangeFactory> changeFactory;

	std::vector<MilestoneNode> milestones;
	std::vector<MilestoneNode*> actives;

	std::unordered_map<std::string, ValueType> variables;

	// 复合对象读取
	std::shared_ptr<Event> BuildEvent(Json::Value root);
	std::vector<Dialog> BuildDialogs(Json::Value root);
	std::vector<std::shared_ptr<Change>> BuildChanges(Json::Value root);
	Condition BuildCondition(Json::Value root);

	// 初始化全局变量
	void InitVariables();
	void SetValue(const std::string& name, ValueType value);
	ValueType GetValue(const std::string& name);
};



// ===== .\Forever\society.cpp =====

﻿#include "utility.h"
#include "error.h"
#include "society.h"
#include "json.h"

#include <fstream>
#include <filesystem>


using namespace std;

Society::Society() {
    calendarFactory.reset(new CalendarFactory());
    organizationFactory.reset(new OrganizationFactory());
}

Society::~Society() {
    for (auto& mod : modHandles) {
        if (mod) {
            FreeLibrary(mod);
        }
    }
    modHandles.clear();
}

void Society::InitCalendars() {
    calendarFactory->RegisterCalendar(TestCalendar::GetId(), []() { return make_unique<TestCalendar>(); });

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully.\n");

        RegisterModCalendarsFunc registerFunc = (RegisterModCalendarsFunc)GetProcAddress(modHandle, "RegisterModCalendars");
        if (registerFunc) {
            registerFunc(calendarFactory.get());
        }
        else {
            debugf("Incorrect dll content.");
        }
    }
    else {
        debugf("Failed to load mod.dll.");
    }

#ifdef MOD_TEST
    auto calendarList = { "test", "mod" };
    for (const auto& calendarId : calendarList) {
        if (calendarFactory->CheckRegistered(calendarId)) {
            auto calendar = calendarFactory->CreateCalendar(calendarId);
            debugf(("Created calendar: " + calendar->GetName() + " (ID: " + calendarId + ")\n").data());
        }
        else {
            debugf("Calendar not registered: %s\n", calendarId);
        }
    }
#endif // MOD_TEST
}

void Society::InitOrganizations() {
    organizationFactory->RegisterOrganization(TestOrganization::GetId(),
        []() { return make_unique<TestOrganization>(); }, TestOrganization::GetPower());

    HMODULE modHandle = LoadLibraryA(REPLACE_PATH("Mod.dll"));
    if (modHandle) {
        modHandles.push_back(modHandle);
        debugf("Mod dll loaded successfully\n");

        RegisterModOrganizationsFunc registerFunc = (RegisterModOrganizationsFunc)GetProcAddress(modHandle, "RegisterModOrganizations");
        if (registerFunc) {
            registerFunc(organizationFactory.get());
        }
        else {
            debugf("Incorrect dll content\n");
        }
    }
    else {
        debugf("Failed to load mod.dll\n");
    }

#ifdef MOD_TEST
    auto organizationList = { "test", "mod" };
    for (const auto& organizationId : organizationList) {
        if (organizationFactory->CheckRegistered(organizationId)) {
            auto organization = organizationFactory->CreateOrganization(organizationId);
            debugf(("Created organization: " + organization->GetName() + " (ID: " + organizationId + ")\n").data());
        }
        else {
            debugf("Organization not registered: %s\n", organizationId);
        }
    }
#endif // MOD_TEST

}

void Society::Init(std::unique_ptr<Map>& map, std::unique_ptr<Populace>& populace) {
	auto components = map->GetComponents();

	unordered_map<string, vector<shared_ptr<Component>>> componentMap;
    for (auto component : components) {
        if(componentMap.find(component->GetType()) == componentMap.end())
			componentMap[component->GetType()] = vector<shared_ptr<Component>>();
		componentMap[component->GetType()].push_back(component);
    }

    auto powers = organizationFactory->GetPowers();
    vector<pair<string, float>> cdfs;
    float sum = 0.f;
    for (auto power : powers) {
        sum += power.second;
        cdfs.emplace_back(power.first, sum);
    }
    if (sum == 0.f) {
        THROW_EXCEPTION(InvalidArgumentException, "No valid organization for generation.\n");
    }
    for (auto& cdf : cdfs) {
        cdf.second /= sum;
    }

	int attempt = 0;
    while(attempt < 16) {
        float r = GetRandom(1000) / 1000.f;
        string selectedOrganization;
        for (auto& cdf : cdfs) {
            if (r <= cdf.second) {
                selectedOrganization = cdf.first;
                break;
            }
        }
        shared_ptr<Organization> organization = organizationFactory->CreateOrganization(selectedOrganization);
        if (!organization) {
            attempt++;
            continue;
        }

        auto requirements = organization->ComponentRequirements();
        bool valid = true;
        for (auto& req : requirements) {
            auto it = componentMap.find(req.first);
            if (it == componentMap.end()) {
                valid = false;
                break;
            }
            if(it->second.size() < req.second.first) {
                valid = false;
                break;
			}
        }
        if (!valid) {
            attempt++;
            continue;
        }

        organizations.push_back(organization);
		std::vector<std::pair<std::string, int>> usedComponents;
        for (auto& req : requirements) {
            auto it = componentMap.find(req.first);
            if (it->second.size() < req.second.second) {
                usedComponents.emplace_back(req.first, (int)it->second.size());
            }
            else {
                usedComponents.emplace_back(req.first, req.second.first + GetRandom(req.second.second - req.second.first));
            }
        }

		auto jobArrangements = organization->ArrageVacancies(usedComponents);
        for (int i = 0; i < usedComponents.size(); i++) {
            auto& type = usedComponents[i].first;
            auto& count = usedComponents[i].second;
            auto& availableComponents = componentMap[type];
            for (int j = 0; j < count; j++) {
                auto component = availableComponents.back();
                availableComponents.pop_back();
                vector<shared_ptr<Job>> jobs;
                for (auto& jobName : jobArrangements[i].second) {
                    shared_ptr<Job> job = populace->GetJobFactory()->CreateJob(jobName);
                    if (job) {
                        jobs.push_back(job);
                    }
                }
                organization->AddVacancy(component, jobs);
            }
        }

		organization->SetCalendar(calendarFactory.get());
	}

    // 分配工作
    std::vector<std::shared_ptr<Organization>> temps;
    for (auto organization : organizations) {
        temps.push_back(organization);
    }
    auto adults = vector<shared_ptr<Person>>();
    for (auto citizen : populace->GetCitizens()) {
        if (citizen->GetAge(populace->GetTime()) < 18)continue;
        adults.push_back(citizen);
    }
    for (auto adult : adults) {
        vector<int> ids;
        ids.push_back(adult->GetId());
        int r = GetRandom((int)temps.size());
        auto jobs = temps[r]->EnrollEmployee(ids);
        if (jobs.size() > 0) {
            adult->AddJob(jobs[0]);
        }
        else {
            temps[r] = temps.back();
            temps.pop_back();
            if (temps.size() <= 0)break;
        }
    }
}

void Society::ReadConfigs(string path) const {
    if (!filesystem::exists(path)) {
        THROW_EXCEPTION(IOException, "Path does not exist: " + path + ".\n");
    }

    Json::Reader reader;
    Json::Value root;

    ifstream fin(path);
    if (!fin.is_open()) {
        THROW_EXCEPTION(IOException, "Failed to open file: " + path + ".\n");
    }
    if (reader.parse(fin, root)) {

    }
    else {
        fin.close();
        THROW_EXCEPTION(JsonFormatException, "Json syntax error: " + reader.getFormattedErrorMessages() + ".\n");
    }
    fin.close();
}

void Society::Destroy() {
    organizations.clear();
}

void Society::Tick() {

}

void Society::Print() {

}

void Society::ApplyChange(shared_ptr<Change> change, unique_ptr<Script>& script) {

}

void Society::Load(string path) {

}

void Society::Save(string path) {

}





// ===== .\Forever\society.h =====

﻿#pragma once

#include "calendar.h"
#include "organization.h"
#include "map.h"
#include "populace.h"

#include <windows.h>


class Society {
public:
	Society();
	~Society();

	// 读取Mods
	void InitCalendars();
	void InitOrganizations();

	// 初始化全部组织
	void Init(std::unique_ptr<Map>& map, std::unique_ptr<Populace>& populace);

	// 读取配置文件
	void ReadConfigs(std::string path) const;

	// 释放空间
	void Destroy();

	// 时钟前进
	void Tick();

	// 输出当前地图
	void Print();

	// 应用变更
	void ApplyChange(std::shared_ptr<Change> change, std::unique_ptr<Script>& script);

	// 保存/加载地图
	void Load(std::string path);
	void Save(std::string path);

private:
	// Mod管理
	std::vector<HMODULE> modHandles;
	std::unique_ptr<CalendarFactory> calendarFactory;
	std::unique_ptr<OrganizationFactory> organizationFactory;

	std::vector<std::shared_ptr<Organization>> organizations;
};



// ===== .\Forever\terrain.cpp =====

﻿#include "terrain.h"


using namespace std;



// ===== .\Forever\terrain.h =====

﻿#pragma once

#include "terrain_base.h"


// 子类注册函数
typedef void (*RegisterModTerrainsFunc)(TerrainFactory* factory);

// 主程序检测子类
class TestTerrain : public Terrain {
public:
    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试地形"; }

    virtual float GetPriority() const override { return 1.0f; };

    virtual void DistributeTerrain(int width, int height,
        std::function<bool(int, int, const std::string)> set, std::function<std::string(int, int)> get) const override {
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < 32; j++) {
                set(i, j, GetType());
                set(i, height - j - 1, GetType());
            }
        }
        for (int j = 0; j < height; j++) {
            for (int i = 0; i < 32; i++) {
                set(i, j, GetType());
                set(width - i - 1, j, GetType());
            }
        }
    }
};


// ===== .\Forever\zone.cpp =====

﻿#include "zone.h"


using namespace std;

int TestZone::count = 0;

function<void(ZoneFactory*, BuildingFactory*, const vector<shared_ptr<Plot>>&)> TestZone::ZoneGenerator =
    [](ZoneFactory* zoneFactory, BuildingFactory* buildingFactory, const vector<shared_ptr<Plot>>& plots) {
        for (const auto& plot : plots) {
            auto zone = zoneFactory->CreateZone(TestZone::GetId());
            if (zone) {
                zone->SetAcreage(40000.f);
				zone->AddBuildings(buildingFactory, { {"test", 1.f}, {"test", 1.f} });
                string name = zone->GetName();
                plot->AddZone(name, move(zone));
            }
        }
    };

// ===== .\Forever\zone.h =====

﻿#pragma once

#include "zone_base.h"


// 子类注册函数
typedef void (*RegisterModZonesFunc)(ZoneFactory* factory);

// 主程序检测子类
class TestZone : public Zone {
public:
    TestZone() {
        name = count++;
    }

    static std::string GetId() { return "test"; }
    virtual std::string GetType() const override { return "test"; }
    virtual std::string GetName() const override { return "测试园区" + std::to_string(name); }

    static std::function<void(ZoneFactory*, BuildingFactory*, const std::vector<std::shared_ptr<Plot>>&)> ZoneGenerator;
    
private:
    static int count;

    int name;
};



// ===== .\Mod\asset_mod.h =====

﻿#pragma once

#include "asset_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModAsset : public Asset {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组资产"; }

};



// ===== .\Mod\building_mod.h =====

﻿#pragma once

#include "building_base.h"

#include "component_mod.h"
#include "room_mod.h"

#include <memory>
#include <string>


// 模组检测子类
class ModBuilding : public Building {
public:
    ModBuilding() {
        name = count++;
    }

    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return std::string("模组建筑") + std::to_string(name); }

    static std::vector<float> GetPower() { return std::vector<float>(13, 1.f); }

    virtual float RandomAcreage() const override { return 10000.f; }
    virtual float GetAcreageMin() const override { return 2000.f; }
    virtual float GetAcreageMax() const override { return 20000.f; }

    virtual void LayoutRooms(RoomFactory* factory, std::unique_ptr<Layout>& layout) override {
        int direction = GetRandom(4);

        auto component = CreateComponent<ModComponent>();
        ReadFloor(0, GetSizeX() / 2.f, GetSizeY() / 2.f, direction, "single_room", layout);
        AssignRoom(0, 0, "mod", component, factory);
    }

private:
    static int count;

    int name;
};

int ModBuilding::count = 0;


// ===== .\Mod\calendar_mod.h =====

﻿#pragma once

#include "calendar_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModCalendar : public Calendar {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组日程"; }

    virtual std::pair<Time, Time> WorkingTime(Time date) const override {
        return { Time("09:00:00.000"), Time("09:00:00.000") };
    }
};



// ===== .\Mod\change_mod.h =====

﻿#pragma once

#include "change_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModChange : public Change {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "mod"; }

    virtual std::vector<std::shared_ptr<Change>> ApplyChange() override {
        return std::vector<std::shared_ptr<Change>>();
    }
};



// ===== .\Mod\component_mod.h =====

﻿#pragma once

#include "component_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModComponent : public Component {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组组合"; }
};



// ===== .\Mod\event_mod.h =====

﻿#pragma once

#include "event_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModEvent : public Event {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "mod"; }

	virtual bool operator==(std::shared_ptr<Event> e) override {
		if (!e)return false;

		return GetType() == e->GetType();
	}
};



// ===== .\Mod\job_mod.h =====

﻿#pragma once

#include "job_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModJob : public Job {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组职业"; }
};



// ===== .\Mod\mod.cpp =====

﻿#include "terrain_mod.h"
#include "roadnet_mod.h"
#include "zone_mod.h"
#include "building_mod.h"
#include "component_mod.h"
#include "room_mod.h"
#include "asset_mod.h"
#include "job_mod.h"
#include "name_mod.h"
#include "scheduler_mod.h"
#include "calendar_mod.h"
#include "event_mod.h"
#include "change_mod.h"
#include "organization_mod.h"

#pragma comment(lib, "Dependence.lib")


using namespace std;

extern "C" __declspec(dllexport) void RegisterModTerrains(TerrainFactory* factory) {
    factory->RegisterTerrain(ModTerrain::GetId(), []() {
        return make_unique<ModTerrain>();
        });
}

extern "C" __declspec(dllexport) void RegisterModRoadnets(RoadnetFactory* factory) {
    factory->RegisterRoadnet(ModRoadnet::GetId(), []() {
        return make_unique<ModRoadnet>();
        });
}

extern "C" __declspec(dllexport) void RegisterModZones(ZoneFactory* factory) {
    factory->RegisterZone(ModZone::GetId(),
        []() { return make_unique<ModZone>(); }, ModZone::ZoneGenerator);
}

extern "C" __declspec(dllexport) void RegisterModBuildings(BuildingFactory* factory) {
    factory->RegisterBuilding(ModZone::GetId(),
        []() { return make_unique<ModBuilding>(); }, ModBuilding::GetPower());
}

extern "C" __declspec(dllexport) void RegisterModComponents(ComponentFactory* factory) {
    factory->RegisterComponent(ModComponent::GetId(), []() {
        return make_unique<ModComponent>();
        });
}

extern "C" __declspec(dllexport) void RegisterModRooms(RoomFactory* factory) {
    factory->RegisterRoom(ModRoom::GetId(), []() {
        return make_unique<ModRoom>();
        });
}

extern "C" __declspec(dllexport) void RegisterModAssets(AssetFactory* factory) {
    factory->RegisterAsset(ModAsset::GetId(), []() {
        return make_unique<ModAsset>();
        });
}

extern "C" __declspec(dllexport) void RegisterModJobs(JobFactory* factory) {
    factory->RegisterJob(ModJob::GetId(), []() {
        return make_unique<ModJob>();
        });
}

extern "C" __declspec(dllexport) void RegisterModNames(NameFactory* factory) {
    factory->RegisterName(ModName::GetId(), []() {
        return make_unique<ModName>();
        });
}

extern "C" __declspec(dllexport) void RegisterModSchedulers(SchedulerFactory* factory) {
    factory->RegisterScheduler(ModScheduler::GetId(), []() {
        return make_unique<ModScheduler>();
        }, ModScheduler::GetPower());
}

extern "C" __declspec(dllexport) void RegisterModCalendars(CalendarFactory* factory) {
    factory->RegisterCalendar(ModCalendar::GetId(), []() {
        return make_unique<ModCalendar>();
        });
}

extern "C" __declspec(dllexport) void RegisterModEvents(EventFactory* factory) {
    factory->RegisterEvent(ModEvent::GetId(), []() {
        return make_unique<ModEvent>();
        });
}

extern "C" __declspec(dllexport) void RegisterModChanges(ChangeFactory* factory) {
    factory->RegisterChange(ModChange::GetId(), []() {
        return make_unique<ModChange>();
        });
}

extern "C" __declspec(dllexport) void RegisterModOrganizations(OrganizationFactory* factory) {
    factory->RegisterOrganization(ModOrganization::GetId(), []() {
        return make_unique<ModOrganization>();
        }, ModOrganization::GetPower());
}


// ===== .\Mod\name_mod.h =====

﻿#pragma once

#include "name_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModName : public Name {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组姓名"; }

    std::string GetSurname(std::string name) override {
        return "";
    }
    virtual std::string GenerateName(bool male = true, bool female = true, bool neutral = true) override {
        return "";
    }
    virtual std::string GenerateName(std::string surname, bool male = true, bool female = true, bool neutral = true) override {
        return "";
    }
};



// ===== .\Mod\organization_mod.h =====

﻿#pragma once

#include "organization_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModOrganization : public Organization {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组组织"; }

    static float GetPower() {
        return 1.0f;
    }

    virtual std::vector<std::pair<std::string, std::pair<int, int>>> ComponentRequirements() const override {
        return std::vector<std::pair<std::string, std::pair<int, int>>>();
    }

    virtual std::vector<std::pair<std::string, std::vector<std::string>>> ArrageVacancies(
        std::vector<std::pair<std::string, int>> components) const override {
		return std::vector<std::pair<std::string, std::vector<std::string>>>();
    }

    virtual void SetCalendar(CalendarFactory* factory) override {
        for (auto component : jobs) {
            for (auto job : component.second) {
                std::shared_ptr<Calendar> calendar = factory->CreateCalendar("mod");
                job.first->SetCalendar(calendar);
            }
        }
    }

};



// ===== .\Mod\roadnet_mod.h =====

﻿#pragma once

#include "roadnet_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModRoadnet : public Roadnet {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组路网"; }

    virtual void DistributeRoadnet(int width, int height,
        std::function<std::string(int, int)> get) override {

    }
};



// ===== .\Mod\room_mod.h =====

﻿#pragma once

#include "room_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModRoom : public Room {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组房间"; }

    virtual bool IsResidential() const override { return false; };
    virtual bool IsWorkspace() const override { return true; }
    virtual int GetLivingCapacity() const override { return 0; }
    virtual int GetPersonnelCapacity() const override { return 2; }
};



// ===== .\Mod\scheduler_mod.h =====

﻿#pragma once

#include "scheduler_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModScheduler : public Scheduler {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组调度"; }

    static float GetPower() {
        return 1.0f;
    }

};



// ===== .\Mod\terrain_mod.h =====

﻿#pragma once

#include "terrain_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModTerrain : public Terrain {
public:
    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组地形"; }

    virtual float GetPriority() const override { return 2.0f; };

    virtual void DistributeTerrain(int width, int height,
        std::function<bool(int, int, const std::string)> set, std::function<std::string(int, int)> get) const override {
        for (int i = 0; i < width; i++) {
            for (int j = 32; j < 64; j++) {
                set(i, j, GetType());
                set(i, height - j - 1, GetType());
            }
        }
        for (int j = 0; j < height; j++) {
            for (int i = 32; i < 64; i++) {
                set(i, j, GetType());
                set(width - i - 1, j, GetType());
            }
        }
    }
};



// ===== .\Mod\zone_mod.h =====

﻿#pragma once

#include "zone_base.h"

#include <memory>
#include <string>


// 模组检测子类
class ModZone : public Zone {
public:
    ModZone() {
        name = count++;
    }

    static std::string GetId() { return "mod"; }
    virtual std::string GetType() const override { return "mod"; }
    virtual std::string GetName() const override { return "模组园区" + std::to_string(name); }

    static std::function<void(ZoneFactory*, BuildingFactory*, const std::vector<std::shared_ptr<Plot>>&)> ZoneGenerator;
    
private:
    static int count;

    int name;
};

int ModZone::count = 0;

std::function<void(ZoneFactory*, BuildingFactory*, const std::vector<std::shared_ptr<Plot>>&)> ModZone::ZoneGenerator =
    [](ZoneFactory* zoneFactory, BuildingFactory* buildingFactory, const std::vector<std::shared_ptr<Plot>>& plots) {
        for (const auto& plot : plots) {
            auto zone = zoneFactory->CreateZone(ModZone::GetId());
            if (zone) {
                zone->SetAcreage(40000.f);
                zone->AddBuildings(buildingFactory, { {"mod", 1.f}, {"mod", 1.f} });
                std::string name = zone->GetName();
                plot->AddZone(name, std::move(zone));
            }
        }
    };


// ===== .\Test\parser.cpp =====

﻿#include "parser.h"
#include "error.h"

#include <algorithm>
#include <sstream>

using namespace std;

void Parser::AddOption(const string& name, char abbreviation,
	const string& help, bool assigned, string value) {
	ValidateName(name);
	
	// 如果给定简写字符，则构建与名称的映射
	if (abbreviation != '\0') {
		if (abbreviation == '-') {
			THROW_EXCEPTION(InvalidArgumentException, "Short option cannot be '-'.\n");
		}

		if (names.find(abbreviation) != names.end()) {
			THROW_EXCEPTION(InvalidArgumentException, string("Short option '") + abbreviation + "' already used.\n");
		}

		names[abbreviation] = name;
	}

	// 记录完整option信息
	options[name] = { abbreviation, value != "", assigned, value, help };
}

vector<string> Parser::ExtractCmd(const string& input) {
	vector<string> tokens;
	string token;
	bool inQuotes = false;
	bool escapeNext = false;

	// 按空格分割
	for (char c : input) {
		if (escapeNext) {
			token += c;
			escapeNext = false;
			continue;
		}

		switch (c) {
		case '\\':
			escapeNext = true;
			break;
		case '"':
			inQuotes = !inQuotes;
			break;
		case ' ':
		case '\t':
			if (inQuotes) {
				token += c;
			}
			else if (!token.empty()) {
				tokens.push_back(token);
				token.clear();
			}
			break;
		default:
			token += c;
		}
	}
	if (!token.empty()) {
		tokens.push_back(token);
	}

	return tokens;
}

void Parser::ParseCmd(vector<string> cmd) {
	if (cmd.size() < 1) return;

	for (size_t i = 0; i < cmd.size(); ++i) {
		const string& arg = cmd[i];

		// --为结束符
		if (arg == "--") break;

		// 通过长名称赋值
		if (arg.substr(0, 2) == "--") {
			string optionName;
			string value;
			size_t pos = arg.find('=');

			// 若存在无空格等号，则等号视为赋值
			if (pos != string::npos) {
				optionName = arg.substr(0, pos);
				value = arg.substr(pos + 1);
			}
			else {
				optionName = arg;
			}

			auto it = options.find(optionName);
			if (it == options.end()) {
				THROW_EXCEPTION(CommandException, "Unknown option: " + optionName + ".\n");
			}

			Option& opt = it->second;
			opt.present = true;

			// 若长名称对应option需要赋值，如果存在无空格等号则取等号后子串，否则取下一个空格后的内容
			if (opt.assigned) {
				if (pos != string::npos) {
					opt.value = value;
				}
				else {
					if (i + 1 >= cmd.size() || cmd[i + 1][0] == '-') {
						THROW_EXCEPTION(CommandException, "Option " + optionName + " requires a value.\n");
					}
					opt.value = cmd[++i];
				}
			}
		}
		// 通过字符赋值
		else if (arg[0] == '-') {
			for (size_t j = 1; j < arg.size(); ++j) {
				char abbreviation = arg[j];
				auto it = names.find(abbreviation);
				if (it == names.end()) {
					THROW_EXCEPTION(CommandException, string("Unknown option: -") + abbreviation + ".\n");
				}

				const string& optionName = it->second;
				Option& opt = options[optionName];
				opt.present = true;

				//若字符对应option需要赋值，如果其后紧跟字符串则取其后子串，否则取下一个空格后的内容
				if (opt.assigned) {
					if (j + 1 < arg.size() || i + 1 < cmd.size()) {
						if (j + 1 < arg.size()) {
							opt.value = arg.substr(j + 1);
						}
						else {
							opt.value = cmd[++i];
						}
						break;
					}
					else {
						THROW_EXCEPTION(CommandException, "Option -" + string(1, abbreviation) + " requires a value.\n");
					}
				}
			}
		}
	}
}

bool Parser::HasOption(const string& name) const {
	auto it = options.find(name);
	if (it == options.end()) {
		THROW_EXCEPTION(CommandException, "Unknown option: " + name + ".\n");
	}
	return it->second.present;
}

const string& Parser::GetOption(const string& name) const {
	auto it = options.find(name);
	if (it == options.end()) {
		THROW_EXCEPTION(CommandException, "Unknown option: " + name + ".\n");
	}
	if (!it->second.assigned) {
		THROW_EXCEPTION(CommandException, "Option " + name + " does not require a value.\n");
	}
	if (!it->second.present) {
		THROW_EXCEPTION(CommandException, "Option " + name + " not present.\n");
	}
	return it->second.value;
}

CMD_TYPE Parser::GetAction(const string& action) const {
	if (action == "init") {
		return CMD_INIT;
	}
	if (action == "pass") {
		return CMD_PASS;
	}
	if (action == "event") {
		return CMD_EVENT;
	}
	if (action == "print") {
		return CMD_PRINT;
	}
	if (action == "exit") {
		return CMD_EXIT;
	}
	return CMD_UNKOWN;
}

void Parser::PrintHelp(CMD_TYPE type) const {
	// 自适应帮助信息
	cout << "Usage: init/pass/print [OPTIONS] [ARGS...]\n\n";
	cout << "Options:\n";

	// 输出当前已添加的参数信息
	for (const auto& pair : options) {
		const Option& opt = pair.second;
		cout << "  ";

		if (opt.abbreviation != '\0') {
			cout << '-' << opt.abbreviation << ", ";
		}
		else {
			cout << "    ";
		}

		cout << pair.first;

		if (opt.assigned) {
			cout << "=VALUE";
		}

		cout << "\n    " << opt.help << "\n\n";
	}
}

void Parser::ValidateName(const string& name) const {
	if (name.empty()) {
		THROW_EXCEPTION(InvalidArgumentException, "Option name cannot be empty.\n");
	}

	if (name.size() < 2 || name[0] != '-' || name[1] != '-') {
		THROW_EXCEPTION(InvalidArgumentException, "Long option name must start with '--'.\n");
	}

	if (name.find('=') != string::npos) {
		THROW_EXCEPTION(InvalidArgumentException, "Option name cannot contain '='.\n");
	}
}



// ===== .\Test\parser.h =====

﻿#pragma once

#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <iostream>

enum CMD_TYPE {
	CMD_UNKOWN, //未知命令
	CMD_INIT, //全局初始化
	CMD_PASS, //时钟前进
	CMD_EVENT, //触发事件
	CMD_PRINT, //状态输出
	CMD_EXIT //退出程序
};

class Parser {
public:
	// 添加参数选项
	void AddOption(const std::string& name, char abbreviation = '\0',
		const std::string& help = "", bool assigned = false, std::string value = "");

	// 从文本提取命令数组
	std::vector<std::string> ExtractCmd(const std::string& input);

	// 解析命令行参数
	void ParseCmd(std::vector<std::string> cmd);

	// 检查选项是否存在
	bool HasOption(const std::string& name) const;

	// 获取选项值
	const std::string& GetOption(const std::string& name) const;

	// 获取命令
	CMD_TYPE GetAction(const std::string& action) const;

	// 打印帮助信息
	void PrintHelp(CMD_TYPE type) const;

private:
	struct Option {
		char abbreviation = 0;
		bool present = false;
		bool assigned = false;
		std::string value;
		std::string help;
	};

	// --xxx, option
	std::map<std::string, Option> options;
	// -x, --xxx
	std::map<char, std::string> names;

	// 检查--xxx字符串
	void ValidateName(const std::string& name) const;
};




// ===== .\Test\test.cpp =====

﻿#include "parser.h"
#include "map.h"
#include "populace.h"
#include "society.h"
#include "script.h"
#include "utility.h"
#include "error.h"

#include <iostream>
#include <memory>

#pragma comment(lib, "Forever.lib")
#pragma comment(lib, "Dependence.lib")


using namespace std;

// 解析命令行输入事件
shared_ptr<Event> ParseEvent(Parser& parser) {
    string type = parser.GetOption("--type");
    string target = "";
    string option = "";

    if (type == "game_start") {
        return make_shared<GameStartEvent>();
    }
	else if (type == "option_dialog") {
		if (parser.HasOption("--target")) target = parser.GetOption("--target");
		if (parser.HasOption("--option")) option = parser.GetOption("--option");
		return make_shared<OptionDialogEvent>(target, option);
	}

    return nullptr;
}

int main() {
	// 读取Map相关类及Mod
	unique_ptr<Map> map(new Map());
	map->InitTerrains();
	map->InitRoadnets();
	map->InitZones();
	map->InitBuildings();
	map->InitComponents();
	map->InitRooms();
	map->ReadConfigs(REPLACE_PATH("../Resources/configs/config_map.json"));

	// 读取Populace相关类及Mod
	unique_ptr<Populace> populace(new Populace());
	populace->InitAssets();
	populace->InitJobs();
	populace->InitNames();
	populace->InitSchedulers();
	populace->ReadConfigs(REPLACE_PATH("../Resources/configs/config_populace.json"));

	// 读取Society相关类及Mod
	unique_ptr<Society> society(new Society());
	society->InitCalendars();
	society->InitOrganizations();
	society->ReadConfigs(REPLACE_PATH("../Resources/configs/config_society.json"));

	// 读取Script相关类及Mod
	unique_ptr<Script> script(new Script());
	script->InitEvents();
	script->InitChanges();

	// 读取命令行
	string cmd;
	CMD_TYPE type = CMD_UNKOWN;
	do {
		// 读取一行命令
		string input;
		getline(cin, input);

		// 添加帮助选项
		Parser parser;
		parser.AddOption("--help", 'h', "Show help.");

		// 空格分解命令
		auto cmd = parser.ExtractCmd(input);
		if (cmd.size() <= 0)continue;
		auto type = parser.GetAction(cmd[0]);

		try {
			switch (type) {
			case CMD_INIT: { // 初始化世界、人口、剧本
				parser.AddOption("--block", 0, "Block num both horizontally and vertically.", true, "4");
				parser.AddOption("--story", 0, "Story file.", true, REPLACE_PATH("../Resources/scripts/ys.json"));
				parser.ParseCmd(cmd);
				int size = atoi(parser.GetOption("--block").data());
				populace->Init(map->Init(size, size));
				map->Checkin(populace->GetCitizens(), populace->GetTime());
				society->Init(map, populace);
				populace->Schedule();
				string path = parser.GetOption("--story");
				script->ReadScript(path);
				break;
			}
			case CMD_PASS: { // 时间流逝
				parser.AddOption("--tick", 0, "Ticks num to pass.", true, "0");
				parser.AddOption("--sec", 0, "Seconds num to pass.", true, "0");
				parser.AddOption("--min", 0, "Minutes num to pass.", true, "0");
				parser.AddOption("--day", 0, "Days num to pass.", true, "0");
				parser.ParseCmd(cmd);

				break;
			}
			case CMD_EVENT: { // 文本模拟事件
				parser.AddOption("--type", 0, "Event type.", true, "nothing_happen");

				parser.AddOption("--target", 0, "Event target.", true, "");
				parser.AddOption("--option", 0, "Event option.", true, "");

				parser.ParseCmd(cmd);
				auto event = ParseEvent(parser);
				auto actions = script->MatchEvent(event);
				auto dialogs = actions.first;
				auto changes = actions.second;
				for (auto dialog : dialogs) {
					if (script->JudgeCondition(dialog.GetCondition())) {
						auto contents = dialog.GetDialogs();
						if (contents.size() > 0) {
							for (auto content : contents) {
								if (content.first.size() == 0)
									cout << script->ReplaceContent(content.second) << endl;
								else
									cout << script->ReplaceContent(content.first) << ": " << script->ReplaceContent(content.second) << endl;
							}
							break;
						}
					}
				}
				for (auto change : changes) {
					if (!script->JudgeCondition(change->GetCondition()))continue;
					map->ApplyChange(change, script);
					populace->ApplyChange(change, script);
					script->ApplyChange(change);
				}
				break;
			}
			case CMD_PRINT: { // 输出当前状态
				parser.AddOption("--map", 'm', "Whether to print the map.", false);
				parser.AddOption("--populace", 'p', "Whether to print the populace.", false);
				parser.AddOption("--script", 's', "Whether to print the script.", false);

				parser.ParseCmd(cmd);
				break;
			}
			default:
				parser.ParseCmd(cmd);

				break;
			}

			// 输出帮助
			if (parser.HasOption("--help")) {
				parser.PrintHelp(type);
			}
		}
		catch (ExceptionBase &e) {
			cout << e.GetDetailedInfo() << endl;
		}

	} while (type != CMD_EXIT);

	return 0;
}

